# GPS & ì¹¼ë§Œ í•„í„° ê¸°ë°˜ í—¬ìŠ¤ì¼€ì–´ ê²Œì´ë¯¸í”¼ì¼€ì´ì…˜ í”Œë«í¼

ìš´ë™í•˜ë©´ì„œ ë•…ë”°ë¨¹ê¸°! GPSì™€ ì„¼ì„œë¡œ ë‚´ ìœ„ì¹˜ë¥¼ ì •í™•íˆ ì¶”ì í•˜ê³ , ë‹¬ë¦¬ë©´ì„œ ì§€ë„ ìœ„ ì˜ì—­ì„ ì •ë³µí•˜ëŠ” ê²Œì„í˜• ìš´ë™ ì•±

## 1. í”„ë¡œì íŠ¸ í•œëˆˆì— ë³´ê¸°

**ìŠ¤ë§ˆíŠ¸í° GPSëŠ” ê°€ë” íŠ€ì–´ìš”!**

ê±´ë¬¼ ì˜†ì„ ì§€ë‚˜ê±°ë‚˜, êµ¬ë¦„ì´ ë§ì€ ë‚ ì—ëŠ” GPSê°€ ê°‘ìê¸° 10ë¯¸í„°ì”© ì í”„í•˜ê¸°ë„ í•©ë‹ˆë‹¤.
ì´ í”„ë¡œì íŠ¸ëŠ” **ì—¬ëŸ¬ ì„¼ì„œë¥¼ í•©ì³ì„œ** GPS ì˜¤ì°¨ë¥¼ ë³´ì •í•˜ê³ , ì •í™•í•œ ìœ„ì¹˜ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.

### ìµœì¢… ëª©í‘œ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ğŸƒ ì‚¬ìš©ìê°€ ë‹¬ë¦¬ë©´...                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚    ğŸ“ GPS: "ì§€ê¸ˆ ì—¬ê¸°!"     â†’   ğŸ§® ì¹¼ë§Œí•„í„°   â†’   ğŸ“Œ ì •í™•í•œ ìœ„ì¹˜!     â”‚
â”‚    ğŸ”„ ìì´ë¡œ: "ì™¼ìª½ìœ¼ë¡œ ë”"  â†’   (ë°ì´í„° ìœµí•©)  â†’   ğŸ—ºï¸ ì§€ë„ì— ê²½ë¡œ í‘œì‹œ â”‚  
â”‚    ğŸ“ ê°€ì†ë„: "ì•ìœ¼ë¡œ ê°€ì†"  â†’                 â†’   ğŸ® ì˜ì—­ ì •ë³µ!      â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ì™œ ì§ì ‘ ë§Œë“œë‚˜ìš”?

| ì¼ë°˜ì ì¸ ë°©ë²•                        | ì´ í”„ë¡œì íŠ¸                   |
| ------------------------------------ | ----------------------------- |
| ìŠ¤ë§ˆíŠ¸í°ì´ ì£¼ëŠ” GPS ì¢Œí‘œ ê·¸ëŒ€ë¡œ ì‚¬ìš© | ì„¼ì„œ Raw ë°ì´í„°ë¶€í„° ì§ì ‘ ì²˜ë¦¬ |
| ì˜¤ì°¨ê°€ ìˆì–´ë„ ê·¸ëƒ¥ ì‚¬ìš©              | ì¹¼ë§Œ í•„í„°ë¡œ ì˜¤ì°¨ ë³´ì •         |
| ì™„ì„±ëœ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì‚¬ìš©               | ìˆ˜í•™ ê³µì‹ë¶€í„° ì§ì ‘ êµ¬í˜„       |

---

## 2. ê¸°ìˆ  ìŠ¤íƒ ì´ì •ë¦¬

### ğŸ“Š ì „ì²´ ê¸°ìˆ  ìŠ¤íƒ ë‹¤ì´ì–´ê·¸ë¨

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                              ê¸°ìˆ  ìŠ¤íƒ Overview                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚   ì„ë² ë””ë“œ/íŒì›¨ì–´   â”‚    â”‚    ë°±ì—”ë“œ ì„œë²„    â”‚    â”‚   í”„ë¡ íŠ¸ì—”ë“œ/ì•±   â”‚         â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤         â”‚
â”‚  â”‚ â€¢ C/C++         â”‚    â”‚ â€¢ Python        â”‚    â”‚ â€¢ React Native  â”‚         â”‚
â”‚  â”‚ â€¢ ESP-IDF       â”‚    â”‚ â€¢ FastAPI       â”‚    â”‚ â€¢ TypeScript    â”‚         â”‚
â”‚  â”‚ â€¢ FreeRTOS      â”‚    â”‚ â€¢ Kafka         â”‚    â”‚ â€¢ Mapbox GL     â”‚         â”‚
â”‚  â”‚ â€¢ Arduino       â”‚    â”‚ â€¢ TimescaleDB   â”‚    â”‚                 â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚           â”‚                      â”‚                      â”‚                   â”‚
â”‚           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
â”‚                                  â–¼                                          â”‚
â”‚                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                  â”‚
â”‚                        â”‚   ë°ì´í„° ë¶„ì„     â”‚                                  â”‚
â”‚                        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                                  â”‚
â”‚                        â”‚ â€¢ Python        â”‚                                  â”‚
â”‚                        â”‚ â€¢ NumPy/SciPy   â”‚                                  â”‚
â”‚                        â”‚ â€¢ Matplotlib    â”‚                                  â”‚
â”‚                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                  â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ğŸ› ï¸ ë ˆì´ì–´ë³„ ê¸°ìˆ  ìŠ¤íƒ

| ë ˆì´ì–´               | ê¸°ìˆ          | ë²„ì „      | ìš©ë„                   |
| -------------------- | ------------ | --------- | ---------------------- |
| **ì„ë² ë””ë“œ**   | C/C++        | C11/C++17 | ESP32 íŒì›¨ì–´ ê°œë°œ      |
|                      | ESP-IDF      | v5.1      | ê³µì‹ ê°œë°œ í”„ë ˆì„ì›Œí¬   |
|                      | FreeRTOS     | -         | ì‹¤ì‹œê°„ ë©€í‹°íƒœìŠ¤í‚¹      |
|                      | Arduino      | -         | ë¹ ë¥¸ í”„ë¡œí† íƒ€ì´í•‘ìš©    |
| **í†µì‹ **       | BLE 5.0      | -         | ë””ë°”ì´ìŠ¤ â†” ì•± í†µì‹     |
|                      | I2C          | -         | ì„¼ì„œ â†” MCU í†µì‹        |
|                      | UART         | -         | GPS â†” MCU í†µì‹         |
| **ë°±ì—”ë“œ**     | Python       | 3.11+     | ë©”ì¸ ì–¸ì–´              |
|                      | FastAPI      | 0.100+    | REST API ì„œë²„          |
|                      | Kafka        | 3.5+      | ì‹¤ì‹œê°„ ë©”ì‹œì§€ ìŠ¤íŠ¸ë¦¬ë° |
|                      | TimescaleDB  | 2.11+     | ì‹œê³„ì—´ ë°ì´í„° ì €ì¥     |
| **í”„ë¡ íŠ¸ì—”ë“œ** | React Native | 0.72+     | í¬ë¡œìŠ¤í”Œë«í¼ ì•±        |
|                      | TypeScript   | 5.0+      | íƒ€ì… ì•ˆì •ì„±            |
|                      | Mapbox GL    | 10.0+     | ì§€ë„ ì‹œê°í™”            |
| **ë¶„ì„**       | NumPy        | 1.24+     | ìˆ˜ì¹˜ ê³„ì‚°              |
|                      | SciPy        | 1.11+     | ì¹¼ë§Œ í•„í„° êµ¬í˜„         |
|                      | Matplotlib   | 3.7+      | ë°ì´í„° ì‹œê°í™”          |

---

## 3. ì‹œìŠ¤í…œ ì „ì²´ êµ¬ì¡°

### ğŸ“Š ë°ì´í„°ê°€ íë¥´ëŠ” ê¸¸

```
  [ì†ëª©ì— ì°¬ ì›¨ì–´ëŸ¬ë¸” ê¸°ê¸°]
         â”‚
         â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚                    ì„¼ì„œë“¤ (3ê°€ì§€)                              â”‚
  â”‚                                                              â”‚
  â”‚   ğŸ›°ï¸ GPS ëª¨ë“ˆ        ğŸ”„ IMU ì„¼ì„œ           â¤ï¸ ì‹¬ë°• ì„¼ì„œ         â”‚
  â”‚   (NEO-M9N)         (MPU-9250)           (MAX30102)         â”‚
  â”‚   "ìœ„ë„/ê²½ë„ ì•Œë ¤ì¤Œ"   "í”ë“¤ë¦¼/íšŒì „ ê°ì§€"      "ì‹¬ì¥ ë°•ë™ ì¸¡ì •"     â”‚
  â”‚        â”‚ UART              â”‚ I2C                â”‚ I2C        â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚                  â”‚                    â”‚
           â–¼                  â–¼                    â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚                   ğŸ§  ESP32-S3 (ë‘ë‡Œ)                          â”‚
  â”‚                                                              â”‚
  â”‚   [Step 1] Raw ë°ì´í„° ìˆ˜ì§‘ (0xFF, 0xAD ê°™ì€ ìˆ«ìë“¤)              â”‚
  â”‚       â†“                                                      â”‚
  â”‚   [Step 2] ë¬¼ë¦¬ ë‹¨ìœ„ë¡œ ë³€í™˜ (-0.05 m/sÂ² ê°™ì€ ì˜ë¯¸ìˆëŠ” ê°’)         â”‚
  â”‚       â†“                                                      â”‚
  â”‚   [Step 3] ì¹¼ë§Œ í•„í„° ì ìš© (ìœ„ì¹˜/ì†ë„/ë°©í–¥ ì¶”ì •)                   â”‚
  â”‚       â†“                                                      â”‚
  â”‚   [Step 4] ê²Œì„ ë¡œì§ (ì˜ì—­ ì •ë³µ ê³„ì‚°)                           â”‚
  â”‚                                                              â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â–¼                               â–¼
     ğŸ“± ìŠ¤ë§ˆíŠ¸í° ì•±                      ğŸ’¾ SD ì¹´ë“œ
     (ì§€ë„ì— í‘œì‹œ)                      (ë°ì´í„° ì €ì¥)
```

---

## 4. í•˜ë“œì›¨ì–´ êµ¬ì„±

### ğŸ§© ì‚¬ìš©í•˜ëŠ” ë¶€í’ˆë“¤

| ë¶€í’ˆ                 | ëª¨ë¸ëª…      | í•˜ëŠ” ì¼                          | ì—°ê²° ë°©ì‹          |
| -------------------- | ----------- | -------------------------------- | ------------------ |
| **ë‘ë‡Œ (MCU)** | ESP32-S3    | ëª¨ë“  ê³„ì‚°ì„ ë‹´ë‹¹í•˜ëŠ” ì†Œí˜• ì»´í“¨í„° | -                  |
| **GPS**        | NEO-M9N     | ìœ„ì„±ì—ì„œ ì‹ í˜¸ ë°›ì•„ ìœ„ì¹˜ ê³„ì‚°     | UART (ë¬¸ìë¡œ ëŒ€í™”) |
| **IMU**        | MPU-9250    | ì›€ì§ì„ ê°ì§€ (ê°€ì†ë„+íšŒì „+ë‚˜ì¹¨ë°˜) | I2C (ë²ˆí˜¸ë¡œ ëŒ€í™”)  |
| **ì‹¬ë°•**       | MAX30102    | ì†ëª© í˜ˆê´€ì— ë¹› ì´ì„œ ë§¥ë°• ì¸¡ì •    | I2C                |
| **ë°°í„°ë¦¬**     | LiPo 500mAh | ì „ì› ê³µê¸‰ (3.7V)                 | -                  |

### ğŸ”‹ ì „ì› ë¬¸ì œ

```
ë°°í„°ë¦¬: 3.7V  â†’  ê·¸ëŸ°ë° MCUëŠ” 3.3Vë§Œ ë°›ìŒ!  â†’  ë ˆê·¤ë ˆì´í„°ë¡œ ì „ì•• ë‚®ì¶¤
         âš¡                  âš ï¸                     âœ…
```

### ğŸ“Œ í•€ ì—°ê²°ë„ (Wiring Diagram)

```
ESP32-S3 í•€ ë°°ì¹˜:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                ESP32-S3             â”‚
â”‚                                     â”‚
â”‚  GPIO 21 (SDA) â”€â”€â”€â”€â”¬â”€â”€â”€â”€ MPU-9250 SDA
â”‚  GPIO 22 (SCL) â”€â”€â”€â”€â”¼â”€â”€â”€â”€ MPU-9250 SCL
â”‚                    â”‚
â”‚                    â”œâ”€â”€â”€â”€ MAX30102 SDA
â”‚                    â””â”€â”€â”€â”€ MAX30102 SCL
â”‚                                     â”‚
â”‚  GPIO 16 (RX) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ NEO-M9N TX â”‚
â”‚  GPIO 17 (TX) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ NEO-M9N RX â”‚
â”‚                                     â”‚
â”‚  3.3V â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ì„¼ì„œ VCC  â”‚
â”‚  GND â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ì„¼ì„œ GND  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 5. Step 1: ì„¼ì„œ ë°ì´í„° ì½ê¸°

### ğŸ¤” ì„¼ì„œê°€ ë³´ë‚´ëŠ” ë°ì´í„°ëŠ” ì–´ë–»ê²Œ ìƒê²¼ë‚˜ìš”?

ì„¼ì„œëŠ” ìš°ë¦¬ê°€ ì•„ëŠ” "10ë¯¸í„°", "5ë„" ê°™ì€ ìˆ«ìê°€ ì•„ë‹ˆë¼, **2ì§„ìˆ˜ ë°ì´í„°**ë¥¼ ë³´ëƒ…ë‹ˆë‹¤!

### ğŸ“Ÿ GPSê°€ ë³´ë‚´ëŠ” ë°ì´í„° ì˜ˆì‹œ

GPSëŠ” **NMEA**ë¼ëŠ” í˜•ì‹ì˜ ë¬¸ìì—´ì„ ë³´ëƒ…ë‹ˆë‹¤:

```
$GPGGA,092750.000,3723.4657,N,12202.2694,W,1,8,1.03,61.7,M,-21.3,M,,*5C
  â”‚       â”‚          â”‚     â”‚      â”‚     â”‚ â”‚ â”‚  â”‚    â”‚
  â”‚       â”‚          â”‚     â”‚      â”‚     â”‚ â”‚ â”‚  â”‚    â””â”€ í•´ë°œ ê³ ë„
  â”‚       â”‚          â”‚     â”‚      â”‚     â”‚ â”‚ â”‚  â””â”€â”€â”€â”€â”€â”€ ì •í™•ë„
  â”‚       â”‚          â”‚     â”‚      â”‚     â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€ ìœ„ì„± ê°œìˆ˜
  â”‚       â”‚          â”‚     â”‚      â”‚     â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ GPS í’ˆì§ˆ
  â”‚       â”‚          â”‚     â”‚      â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ê²½ë„ (ì„œê²½)
  â”‚       â”‚          â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ìœ„ë„ (ë¶ìœ„)
  â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ì‹œê°„
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ë°ì´í„° ì¢…ë¥˜
```

### ğŸ’» GPS íŒŒì‹± ì½”ë“œ (Cì–¸ì–´ - ESP32)

```c
// gps_parser.c - GPS NMEA ë¬¸ìì—´ íŒŒì‹±

#include <string.h>
#include <stdlib.h>

typedef struct {
    double latitude;      // ìœ„ë„
    double longitude;     // ê²½ë„
    float altitude;       // ê³ ë„
    int satellites;       // ìœ„ì„± ìˆ˜
    float hdop;          // ì •í™•ë„
} GPSData;

// NMEA ë¬¸ìì—´ì—ì„œ GPS ë°ì´í„° ì¶”ì¶œ
bool parse_gpgga(const char* nmea, GPSData* gps) {
    // $GPGGA ë¡œ ì‹œì‘í•˜ëŠ”ì§€ í™•ì¸
    if (strncmp(nmea, "$GPGGA", 6) != 0) {
        return false;
    }
  
    char* token;
    char buffer[100];
    strcpy(buffer, nmea);
  
    int field = 0;
    token = strtok(buffer, ",");
  
    while (token != NULL) {
        switch (field) {
            case 2:  // ìœ„ë„ (3723.4657)
                gps->latitude = atof(token);
                // DDMM.MMMM â†’ DD.DDDDDD ë³€í™˜
                int deg = (int)(gps->latitude / 100);
                double min = gps->latitude - (deg * 100);
                gps->latitude = deg + (min / 60.0);
                break;
            
            case 4:  // ê²½ë„ (12202.2694)
                gps->longitude = atof(token);
                deg = (int)(gps->longitude / 100);
                min = gps->longitude - (deg * 100);
                gps->longitude = deg + (min / 60.0);
                break;
            
            case 7:  // ìœ„ì„± ìˆ˜
                gps->satellites = atoi(token);
                break;
            
            case 8:  // HDOP (ì •í™•ë„)
                gps->hdop = atof(token);
                break;
            
            case 9:  // ê³ ë„
                gps->altitude = atof(token);
                break;
        }
        token = strtok(NULL, ",");
        field++;
    }
  
    return true;
}

// ì‚¬ìš© ì˜ˆì‹œ
void read_gps_example() {
    const char* nmea = "$GPGGA,092750.000,3723.4657,N,12202.2694,W,1,8,1.03,61.7,M,,*5C";
    GPSData gps;
  
    if (parse_gpgga(nmea, &gps)) {
        printf("ìœ„ë„: %.6f\n", gps.latitude);       // 37.390762
        printf("ê²½ë„: %.6f\n", gps.longitude);      // 122.037823
        printf("ìœ„ì„± ìˆ˜: %d\n", gps.satellites);     // 8
    }
}
```

### ğŸ”¢ IMUê°€ ë³´ë‚´ëŠ” ë°ì´í„° ì˜ˆì‹œ

MPU-9250 ì„¼ì„œëŠ” **I2C í†µì‹ **ìœ¼ë¡œ 16ì§„ìˆ˜ ë°ì´í„°ë¥¼ ë³´ëƒ…ë‹ˆë‹¤:

```
ì£¼ì†Œ      ì´ë¦„           ê°’ (16ì§„ìˆ˜)    ê°’ (2ì§„ìˆ˜)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
0x3B   ACCEL_X ìƒìœ„    0xFF          1111 1111
0x3C   ACCEL_X í•˜ìœ„    0xAD          1010 1101
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ í•©ì¹˜ë©´: -83 (ìŒìˆ˜!)

0x3D   ACCEL_Y ìƒìœ„    0x00          0000 0000  
0x3E   ACCEL_Y í•˜ìœ„    0xC8          1100 1000
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ í•©ì¹˜ë©´: 200 (ì–‘ìˆ˜!)

0x3F   ACCEL_Z ìƒìœ„    0x40          0100 0000
0x40   ACCEL_Z í•˜ìœ„    0x74          0111 0100
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ í•©ì¹˜ë©´: 16,500 (ì•½ 1g!)
```

### ğŸ’» IMU ì½ê¸° ì½”ë“œ (Cì–¸ì–´ - ESP32)

```c
// mpu9250.c - MPU-9250 ì„¼ì„œ ë°ì´í„° ì½ê¸°

#include "driver/i2c.h"

#define MPU9250_ADDR    0x68    // I2C ì£¼ì†Œ
#define ACCEL_XOUT_H    0x3B    // ê°€ì†ë„ X ìƒìœ„ ë°”ì´íŠ¸ ë ˆì§€ìŠ¤í„°

typedef struct {
    int16_t accel_x;    // Xì¶• ê°€ì†ë„ (Raw)
    int16_t accel_y;    // Yì¶• ê°€ì†ë„ (Raw)
    int16_t accel_z;    // Zì¶• ê°€ì†ë„ (Raw)
    int16_t gyro_x;     // Xì¶• ìì´ë¡œ (Raw)
    int16_t gyro_y;     // Yì¶• ìì´ë¡œ (Raw)
    int16_t gyro_z;     // Zì¶• ìì´ë¡œ (Raw)
} IMURawData;

// I2Cë¡œ 1ë°”ì´íŠ¸ ì½ê¸°
uint8_t i2c_read_byte(uint8_t addr, uint8_t reg) {
    uint8_t data;
    i2c_master_write_read_device(I2C_NUM_0, addr, &reg, 1, &data, 1, 100);
    return data;
}

// MPU-9250ì—ì„œ Raw ë°ì´í„° ì½ê¸°
void mpu9250_read_raw(IMURawData* data) {
    uint8_t buffer[14];  // ê°€ì†ë„ 6ë°”ì´íŠ¸ + ì˜¨ë„ 2ë°”ì´íŠ¸ + ìì´ë¡œ 6ë°”ì´íŠ¸
  
    // 0x3Bë¶€í„° 14ë°”ì´íŠ¸ ì—°ì† ì½ê¸°
    uint8_t reg = ACCEL_XOUT_H;
    i2c_master_write_read_device(I2C_NUM_0, MPU9250_ADDR, &reg, 1, buffer, 14, 100);
  
    // ìƒìœ„/í•˜ìœ„ ë°”ì´íŠ¸ ê²°í•© (Big Endian â†’ int16_t)
    data->accel_x = (buffer[0] << 8) | buffer[1];   // 0x3B, 0x3C
    data->accel_y = (buffer[2] << 8) | buffer[3];   // 0x3D, 0x3E
    data->accel_z = (buffer[4] << 8) | buffer[5];   // 0x3F, 0x40
    // buffer[6], buffer[7] = ì˜¨ë„ (ìƒëµ)
    data->gyro_x  = (buffer[8] << 8) | buffer[9];   // 0x43, 0x44
    data->gyro_y  = (buffer[10] << 8) | buffer[11]; // 0x45, 0x46
    data->gyro_z  = (buffer[12] << 8) | buffer[13]; // 0x47, 0x48
}

// ì‚¬ìš© ì˜ˆì‹œ
void read_imu_example() {
    IMURawData raw;
    mpu9250_read_raw(&raw);
  
    printf("ACCEL_X Raw: %d\n", raw.accel_x);  // -83
    printf("ACCEL_Y Raw: %d\n", raw.accel_y);  // 200
    printf("ACCEL_Z Raw: %d\n", raw.accel_z);  // 16500
    printf("GYRO_Z Raw: %d\n", raw.gyro_z);    // 750
}
```

### ğŸ“ ì™œ ìŒìˆ˜ê°€ ë‚˜ì˜¤ë‚˜ìš”? (2ì˜ ë³´ìˆ˜)

```
ì˜ˆì‹œ: 0xFFADê°€ ì™œ -83ì¸ê°€?

1. 16ì§„ìˆ˜ â†’ 2ì§„ìˆ˜:  1111 1111 1010 1101
2. ë§¨ ì•ì´ 1ì´ë©´ ìŒìˆ˜!
3. ë¹„íŠ¸ ë’¤ì§‘ê¸°:     0000 0000 0101 0010
4. +1 í•˜ê¸°:         0000 0000 0101 0011 = 83
5. ê²°ê³¼: -83
```

### âœ… Step 1 ê²°ê³¼

| ì„¼ì„œ    | Raw ê°’           | ì˜ë¯¸                  |
| ------- | ---------------- | --------------------- |
| ACCEL_X | **-83**    | ì‚´ì§ ë’¤ë¡œ ê°€ì† (ê°ì†) |
| ACCEL_Y | **200**    | ì˜¤ë¥¸ìª½ìœ¼ë¡œ ê¸°ìš¸ì–´ì§   |
| ACCEL_Z | **16,500** | ì¤‘ë ¥ (â‰ˆ1g)           |
| GYRO_Z  | **750**    | ì™¼ìª½ìœ¼ë¡œ íšŒì „ ì¤‘      |

---

## 6. Step 2: ë¬¼ë¦¬ ë‹¨ìœ„ ë³€í™˜

### ğŸ¤” ì™œ ë³€í™˜ì´ í•„ìš”í•œê°€ìš”?

**-83**ì´ë¼ëŠ” ìˆ«ìë§Œ ë´ì„œëŠ” "ì–¼ë§ˆë‚˜ ë¹¨ë¦¬ ê°€ì†í•˜ëŠ”ì§€" ì•Œ ìˆ˜ ì—†ì–´ìš”!
ì´ ìˆ«ìë¥¼ **m/sÂ²** (ë¯¸í„°/ì´ˆÂ²) ê°™ì€ **ë¬¼ë¦¬ ë‹¨ìœ„**ë¡œ ë°”ê¿”ì•¼ ê³„ì‚°ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.

### ğŸ“ ë³€í™˜ ê³µì‹ (ê°€ì†ë„)

```
                    Raw ê°’
ì‹¤ì œ ê°€ì†ë„ = â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Ã— ì¤‘ë ¥ê°€ì†ë„(9.8)
               Sensitivity
```

**Sensitivity(ë¯¼ê°ë„)ë€?**

- Â±2g ëª¨ë“œ: 1g = 16,384
- ì¦‰, ì„¼ì„œê°’ 16,384ê°€ ë‚˜ì˜¤ë©´ = 1g = 9.8 m/sÂ²

### ğŸ’» ë‹¨ìœ„ ë³€í™˜ ì½”ë“œ (Cì–¸ì–´ - ESP32)

```c
// sensor_convert.c - Raw ë°ì´í„°ë¥¼ ë¬¼ë¦¬ ë‹¨ìœ„ë¡œ ë³€í™˜

#include <math.h>

// ìƒìˆ˜ ì •ì˜ (ë¯¸ë¦¬ ê³„ì‚°í•´ë‘ë©´ CPU ì ˆì•½!)
#define ACCEL_SENSITIVITY   16384.0f    // Â±2g ëª¨ë“œ
#define GYRO_SENSITIVITY    131.0f      // Â±250Â°/s ëª¨ë“œ
#define GRAVITY             9.80665f    // í‘œì¤€ ì¤‘ë ¥ ê°€ì†ë„
#define DEG_TO_RAD          (M_PI / 180.0f)

// ìµœì í™”ëœ ìŠ¤ì¼€ì¼ íŒ©í„° (ë‚˜ëˆ—ì…ˆ ëŒ€ì‹  ê³±ì…ˆ ì‚¬ìš©)
#define ACCEL_SCALE     (GRAVITY / ACCEL_SENSITIVITY)    // 0.000598550
#define GYRO_SCALE      (DEG_TO_RAD / GYRO_SENSITIVITY)  // 0.000133158

typedef struct {
    float accel_x;    // m/sÂ²
    float accel_y;    // m/sÂ²
    float accel_z;    // m/sÂ²
    float gyro_x;     // rad/s
    float gyro_y;     // rad/s
    float gyro_z;     // rad/s
} IMUPhysicalData;

// Raw â†’ ë¬¼ë¦¬ ë‹¨ìœ„ ë³€í™˜
void convert_imu_data(const IMURawData* raw, IMUPhysicalData* phys) {
    // ê°€ì†ë„ ë³€í™˜: Raw â†’ m/sÂ²
    phys->accel_x = raw->accel_x * ACCEL_SCALE;
    phys->accel_y = raw->accel_y * ACCEL_SCALE;
    phys->accel_z = raw->accel_z * ACCEL_SCALE;
  
    // ìì´ë¡œ ë³€í™˜: Raw â†’ rad/s
    phys->gyro_x = raw->gyro_x * GYRO_SCALE;
    phys->gyro_y = raw->gyro_y * GYRO_SCALE;
    phys->gyro_z = raw->gyro_z * GYRO_SCALE;
}

// ì‚¬ìš© ì˜ˆì‹œ
void convert_example() {
    IMURawData raw = {-83, 200, 16500, 0, 0, 750};
    IMUPhysicalData phys;
  
    convert_imu_data(&raw, &phys);
  
    printf("ê°€ì†ë„ X: %.4f m/sÂ²\n", phys.accel_x);  // -0.0497
    printf("ê°€ì†ë„ Y: %.4f m/sÂ²\n", phys.accel_y);  //  0.1197
    printf("ê°€ì†ë„ Z: %.4f m/sÂ²\n", phys.accel_z);  //  9.8770 (â‰ˆ1g)
    printf("ê°ì†ë„ Z: %.4f rad/s\n", phys.gyro_z);   //  0.0999
}
```

### ğŸ§® ACCEL_X ê³„ì‚° ì˜ˆì‹œ (ìˆ˜ë™ ê³„ì‚°)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ACCEL_X = -83 ì„ m/sÂ² ë¡œ ë³€í™˜                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                â”‚
â”‚  Step 1: g ë‹¨ìœ„ë¡œ ë³€í™˜                                          â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                         â”‚
â”‚      -83 Ã· 16,384 = -0.00507 g                                 â”‚
â”‚                                                                â”‚
â”‚  Step 2: m/sÂ² ë¡œ ë³€í™˜                                           â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                            â”‚
â”‚      -0.00507 Ã— 9.80665 = -0.0497 m/sÂ²                         â”‚
â”‚                                                                â”‚
â”‚  ê²°ê³¼: ë’¤ìª½ìœ¼ë¡œ 0.0497 m/sÂ² ê°€ì† (ì•„ì£¼ ì‚´ì§ ê°ì† ì¤‘)               â”‚
â”‚                                                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### âœ… Step 2 ê²°ê³¼: ì…ë ¥ ë²¡í„° $u_k$

```
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚  ax = -0.0497 â”‚ â† Xì¶• ê°€ì†ë„ (m/sÂ²)
  u_k =  â”‚  ay =  0.1197 â”‚ â† Yì¶• ê°€ì†ë„ (m/sÂ²)  
         â”‚  Ï‰z =  0.0999 â”‚ â† Zì¶• ê°ì†ë„ (rad/s)
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 7. Step 3: ì¹¼ë§Œ í•„í„° ê³„ì‚°

### ğŸ¤” ì¹¼ë§Œ í•„í„°ê°€ ë­”ê°€ìš”?

**GPSëŠ” ê°€ë” ê±°ì§“ë§ì„ í•´ìš”!** ğŸ˜…

- GPS: "ë„ˆ ì§€ê¸ˆ ì—¬ê¸°!" (ì‹¤ì œë¡œëŠ” 5m ì˜†)
- ì„¼ì„œ: "ê·¼ë° ë„ˆ ë°©ê¸ˆ ì•ìœ¼ë¡œë§Œ ê°”ì–ì•„?"
- ì¹¼ë§Œ í•„í„°: "ë‘˜ ë‹¤ ì°¸ê³ í•´ì„œ... ì•„ë§ˆ ì§„ì§œ ìœ„ì¹˜ëŠ” ì—¬ê¸°ì¼ ê±°ì•¼!"

**ì¹¼ë§Œ í•„í„° = ì—¬ëŸ¬ ì •ë³´ë¥¼ ì¢…í•©í•´ì„œ ê°€ì¥ ê·¸ëŸ´ë“¯í•œ ê°’ì„ ì¶”ì •í•˜ëŠ” ìˆ˜í•™ì  ë°©ë²•**

### ğŸ¯ ìƒíƒœ ë²¡í„° (ìš°ë¦¬ê°€ ì•Œê³  ì‹¶ì€ ê²ƒë“¤)

```
         â”Œâ”€â”€â”€â”€â”€â”
         â”‚ px  â”‚ â† X ìœ„ì¹˜ (ì–´ë””ì— ìˆë‚˜?)
         â”‚ py  â”‚ â† Y ìœ„ì¹˜
  x  =   â”‚ vx  â”‚ â† X ì†ë„ (ì–¼ë§ˆë‚˜ ë¹¨ë¦¬ ê°€ë‚˜?)
         â”‚ vy  â”‚ â† Y ì†ë„
         â”‚ Î¸   â”‚ â† ë°©í–¥ (ì–´ë””ë¥¼ ë³´ê³  ìˆë‚˜?)
         â””â”€â”€â”€â”€â”€â”˜
```

### ğŸ’» ì¹¼ë§Œ í•„í„° ì½”ë“œ (Python - ì‹œë®¬ë ˆì´ì…˜ìš©)

```python
# kalman_filter.py - í™•ì¥ ì¹¼ë§Œ í•„í„° (EKF) êµ¬í˜„

import numpy as np

class ExtendedKalmanFilter:
    """
    2D ìœ„ì¹˜/ì†ë„/ë°©í–¥ ì¶”ì •ì„ ìœ„í•œ í™•ì¥ ì¹¼ë§Œ í•„í„°
  
    ìƒíƒœ ë²¡í„°: [px, py, vx, vy, theta]
    - px, py: ìœ„ì¹˜ (m)
    - vx, vy: ì†ë„ (m/s)
    - theta: ë°©í–¥ (rad)
    """
  
    def __init__(self, dt=0.01):
        self.dt = dt  # ìƒ˜í”Œë§ ê°„ê²© (100Hz = 0.01ì´ˆ)
    
        # ìƒíƒœ ë²¡í„° ì´ˆê¸°í™” [px, py, vx, vy, theta]
        self.x = np.array([0.0, 0.0, 1.5, 0.5, 0.0])
    
        # ì˜¤ì°¨ ê³µë¶„ì‚° í–‰ë ¬ ì´ˆê¸°í™”
        self.P = np.eye(5) * 0.1
    
        # í”„ë¡œì„¸ìŠ¤ ë…¸ì´ì¦ˆ (ì‹œìŠ¤í…œ ë¶ˆí™•ì‹¤ì„±)
        self.Q = np.diag([0.01, 0.01, 0.1, 0.1, 0.01])
    
        # ì¸¡ì • ë…¸ì´ì¦ˆ (GPS ë¶ˆí™•ì‹¤ì„±)
        self.R = np.diag([5.0, 5.0])  # GPS ì˜¤ì°¨ ì•½ 5m
  
    def predict(self, ax, ay, omega_z):
        """
        ì˜ˆì¸¡ ë‹¨ê³„ (Prediction Step)
    
        ì„¼ì„œ ì…ë ¥:
        - ax, ay: ê°€ì†ë„ (m/sÂ²)
        - omega_z: ê°ì†ë„ (rad/s)
        """
        dt = self.dt
        px, py, vx, vy, theta = self.x
    
        # ì¢Œí‘œ íšŒì „ (Body â†’ Global)
        cos_t = np.cos(theta)
        sin_t = np.sin(theta)
        ax_global = ax * cos_t - ay * sin_t
        ay_global = ax * sin_t + ay * cos_t
    
        # ìƒíƒœ ì „ì´ (ë“±ê°€ì†ë„ ìš´ë™ ê³µì‹)
        px_new = px + vx * dt + 0.5 * ax_global * dt**2
        py_new = py + vy * dt + 0.5 * ay_global * dt**2
        vx_new = vx + ax_global * dt
        vy_new = vy + ay_global * dt
        theta_new = theta + omega_z * dt
    
        self.x = np.array([px_new, py_new, vx_new, vy_new, theta_new])
    
        # ì•¼ì½”ë¹„ì•ˆ í–‰ë ¬ ê³„ì‚° (ì„ í˜•í™”)
        F = self._compute_jacobian(ax, ay, theta)
    
        # ì˜¤ì°¨ ê³µë¶„ì‚° ì˜ˆì¸¡
        self.P = F @ self.P @ F.T + self.Q
    
        return self.x.copy()
  
    def update(self, gps_x, gps_y):
        """
        ë³´ì • ë‹¨ê³„ (Update Step)
    
        GPS ì¸¡ì •ê°’ìœ¼ë¡œ ì˜ˆì¸¡ê°’ ë³´ì •
        """
        # ì¸¡ì • í–‰ë ¬ (ìœ„ì¹˜ë§Œ ì¸¡ì • ê°€ëŠ¥)
        H = np.array([
            [1, 0, 0, 0, 0],
            [0, 1, 0, 0, 0]
        ])
    
        # ì¸¡ì •ê°’
        z = np.array([gps_x, gps_y])
    
        # ì˜ˆì¸¡ëœ ì¸¡ì •ê°’
        z_pred = H @ self.x
    
        # ì”ì°¨ (ì¸¡ì •ê°’ - ì˜ˆì¸¡ê°’)
        y = z - z_pred
    
        # ì¹¼ë§Œ ì´ë“ ê³„ì‚°
        S = H @ self.P @ H.T + self.R
        K = self.P @ H.T @ np.linalg.inv(S)
    
        # ìƒíƒœ ë³´ì •
        self.x = self.x + K @ y
    
        # ì˜¤ì°¨ ê³µë¶„ì‚° ë³´ì •
        I = np.eye(5)
        self.P = (I - K @ H) @ self.P
    
        return self.x.copy()
  
    def _compute_jacobian(self, ax, ay, theta):
        """ìƒíƒœ ì „ì´ í•¨ìˆ˜ì˜ ì•¼ì½”ë¹„ì•ˆ (ì„ í˜•í™”)"""
        dt = self.dt
        cos_t = np.cos(theta)
        sin_t = np.sin(theta)
    
        F = np.eye(5)
        F[0, 2] = dt  # dpx/dvx
        F[1, 3] = dt  # dpy/dvy
    
        # dpx/dtheta, dpy/dtheta (ë¹„ì„ í˜• í•­)
        F[0, 4] = (-ax * sin_t - ay * cos_t) * 0.5 * dt**2
        F[1, 4] = (ax * cos_t - ay * sin_t) * 0.5 * dt**2
    
        return F


# ========== ì‚¬ìš© ì˜ˆì‹œ ==========
if __name__ == "__main__":
    ekf = ExtendedKalmanFilter(dt=0.01)
  
    # ì„¼ì„œ ì…ë ¥ê°’ (Step 2ì—ì„œ ë³€í™˜ëœ ê°’)
    ax = -0.0497    # m/sÂ²
    ay = 0.1197     # m/sÂ²
    omega_z = 0.0999  # rad/s
  
    # ì˜ˆì¸¡ ë‹¨ê³„
    predicted = ekf.predict(ax, ay, omega_z)
  
    print("=== ì˜ˆì¸¡ ê²°ê³¼ ===")
    print(f"ìœ„ì¹˜: ({predicted[0]:.6f}, {predicted[1]:.6f}) m")
    print(f"ì†ë„: ({predicted[2]:.6f}, {predicted[3]:.6f}) m/s")
    print(f"ë°©í–¥: {predicted[4]:.6f} rad ({np.degrees(predicted[4]):.3f}Â°)")
```

### ğŸ’» ì¹¼ë§Œ í•„í„° ì½”ë“œ (Cì–¸ì–´ - ESP32 ì„ë² ë””ë“œìš©)

```c
// ekf.c - ì„ë² ë””ë“œìš© í™•ì¥ ì¹¼ë§Œ í•„í„°

#include <math.h>
#include <string.h>

#define STATE_SIZE 5

typedef struct {
    float x[STATE_SIZE];        // ìƒíƒœ ë²¡í„° [px, py, vx, vy, theta]
    float P[STATE_SIZE][STATE_SIZE];  // ì˜¤ì°¨ ê³µë¶„ì‚° í–‰ë ¬
    float dt;                   // ìƒ˜í”Œë§ ê°„ê²©
} EKF;

// ì´ˆê¸°í™”
void ekf_init(EKF* ekf, float dt) {
    ekf->dt = dt;
  
    // ìƒíƒœ ì´ˆê¸°í™”
    memset(ekf->x, 0, sizeof(ekf->x));
    ekf->x[2] = 1.5f;  // ì´ˆê¸° vx
    ekf->x[3] = 0.5f;  // ì´ˆê¸° vy
  
    // P í–‰ë ¬ ì´ˆê¸°í™” (ë‹¨ìœ„ í–‰ë ¬ Ã— 0.1)
    memset(ekf->P, 0, sizeof(ekf->P));
    for (int i = 0; i < STATE_SIZE; i++) {
        ekf->P[i][i] = 0.1f;
    }
}

// ì˜ˆì¸¡ ë‹¨ê³„
void ekf_predict(EKF* ekf, float ax, float ay, float omega_z) {
    float dt = ekf->dt;
    float px = ekf->x[0];
    float py = ekf->x[1];
    float vx = ekf->x[2];
    float vy = ekf->x[3];
    float theta = ekf->x[4];
  
    // ì¢Œí‘œ íšŒì „
    float cos_t = cosf(theta);
    float sin_t = sinf(theta);
    float ax_global = ax * cos_t - ay * sin_t;
    float ay_global = ax * sin_t + ay * cos_t;
  
    // ìƒíƒœ ì—…ë°ì´íŠ¸ (ë“±ê°€ì†ë„ ìš´ë™)
    ekf->x[0] = px + vx * dt + 0.5f * ax_global * dt * dt;
    ekf->x[1] = py + vy * dt + 0.5f * ay_global * dt * dt;
    ekf->x[2] = vx + ax_global * dt;
    ekf->x[3] = vy + ay_global * dt;
    ekf->x[4] = theta + omega_z * dt;
}

// ì‚¬ìš© ì˜ˆì‹œ
void ekf_example() {
    EKF ekf;
    ekf_init(&ekf, 0.01f);  // 100Hz
  
    // ì„¼ì„œê°’ (ë¬¼ë¦¬ ë‹¨ìœ„ë¡œ ë³€í™˜ëœ ê°’)
    float ax = -0.0497f;
    float ay = 0.1197f;
    float omega_z = 0.0999f;
  
    // ì˜ˆì¸¡
    ekf_predict(&ekf, ax, ay, omega_z);
  
    printf("ìœ„ì¹˜: (%.6f, %.6f) m\n", ekf.x[0], ekf.x[1]);
    printf("ì†ë„: (%.6f, %.6f) m/s\n", ekf.x[2], ekf.x[3]);
    printf("ë°©í–¥: %.6f rad\n", ekf.x[4]);
}
```

### âœ… Step 3 ê²°ê³¼: ì˜ˆì¸¡ëœ ìƒíƒœ

| ë³€ìˆ˜ | ì´ì „ ê°’ | ì˜ˆì¸¡ëœ ê°’            | ë³€í™”ëŸ‰  | í•´ì„          |
| ---- | ------- | -------------------- | ------- | ------------- |
| px   | 0 m     | **0.015 m**    | +1.5 cm | ì•ìœ¼ë¡œ ì´ë™   |
| py   | 0 m     | **0.005 m**    | +0.5 cm | ì˜†ìœ¼ë¡œ ì´ë™   |
| vx   | 1.5 m/s | **1.4995 m/s** | -0.0005 | ì‚´ì§ ê°ì†     |
| vy   | 0.5 m/s | **0.5012 m/s** | +0.0012 | ì‚´ì§ ê°€ì†     |
| Î¸   | 0 rad   | **0.001 rad**  | +0.06Â° | ì™¼ìª½ìœ¼ë¡œ íšŒì „ |

---

## 8. Step 4: ê²Œì´ë¯¸í”¼ì¼€ì´ì…˜ ë¡œì§

### ğŸ—ºï¸ ì˜ì—­ ì •ë³µ (ë•…ë”°ë¨¹ê¸°)

**ê·œì¹™:**

1. ì‚¬ìš©ìê°€ ë‹¬ë¦¬ë©´ì„œ ê²½ë¡œë¥¼ ê·¸ë¦½ë‹ˆë‹¤
2. ê²½ë¡œê°€ ë‹«íŒ ë‹¤ê°í˜•ì„ ë§Œë“¤ë©´...
3. ê·¸ ì˜ì—­ì„ "ì •ë³µ"í•œ ê²ƒìœ¼ë¡œ ì¸ì •! ğŸ†

```
        ì‹œì‘ â†’  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                        â”‚
                        â”‚          ì´ ì˜ì—­ì„
                        â”‚          ì •ë³µ!  â­
                        â”‚
        ë   â† â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ğŸ’» Point-in-Polygon ì•Œê³ ë¦¬ì¦˜ (Python)

```python
# territory.py - ì˜ì—­ ì •ë³µ íŒì • ì•Œê³ ë¦¬ì¦˜

from typing import List, Tuple
import numpy as np

Point = Tuple[float, float]

def is_polygon_closed(path: List[Point], threshold: float = 10.0) -> bool:
    """
    ê²½ë¡œê°€ ë‹«íŒ ë‹¤ê°í˜•ì¸ì§€ í™•ì¸
  
    Args:
        path: GPS ì¢Œí‘œ ë¦¬ìŠ¤íŠ¸ [(x1,y1), (x2,y2), ...]
        threshold: ì‹œì‘ì ê³¼ ëì  ì‚¬ì´ ê±°ë¦¬ í—ˆìš©ì¹˜ (ë¯¸í„°)
    """
    if len(path) < 4:  # ìµœì†Œ ì‚¼ê°í˜• + ì‹œì‘ì 
        return False
  
    start = np.array(path[0])
    end = np.array(path[-1])
    distance = np.linalg.norm(end - start)
  
    return distance < threshold


def calculate_polygon_area(vertices: List[Point]) -> float:
    """
    ë‹¤ê°í˜• ë©´ì  ê³„ì‚° (Shoelace ê³µì‹)
  
    Args:
        vertices: ë‹¤ê°í˜• ê¼­ì§“ì  ì¢Œí‘œ
  
    Returns:
        ë©´ì  (ì œê³±ë¯¸í„°)
    """
    n = len(vertices)
    if n < 3:
        return 0.0
  
    area = 0.0
    for i in range(n):
        j = (i + 1) % n
        area += vertices[i][0] * vertices[j][1]
        area -= vertices[j][0] * vertices[i][1]
  
    return abs(area) / 2.0


def point_in_polygon(point: Point, polygon: List[Point]) -> bool:
    """
    ì ì´ ë‹¤ê°í˜• ë‚´ë¶€ì— ìˆëŠ”ì§€ íŒì • (Ray Casting ì•Œê³ ë¦¬ì¦˜)
  
    Args:
        point: íŒì •í•  ì  (x, y)
        polygon: ë‹¤ê°í˜• ê¼­ì§“ì ë“¤
  
    Returns:
        Trueë©´ ë‚´ë¶€, Falseë©´ ì™¸ë¶€
    """
    x, y = point
    n = len(polygon)
    inside = False
  
    j = n - 1
    for i in range(n):
        xi, yi = polygon[i]
        xj, yj = polygon[j]
    
        if ((yi > y) != (yj > y)) and \
           (x < (xj - xi) * (y - yi) / (yj - yi) + xi):
            inside = not inside
    
        j = i
  
    return inside


# ========== ì‚¬ìš© ì˜ˆì‹œ ==========
if __name__ == "__main__":
    # ì‚¬ìš©ìê°€ ë‹¬ë¦° ê²½ë¡œ (GPS ì¢Œí‘œ, ë¯¸í„° ë‹¨ìœ„ë¡œ ë³€í™˜ë¨)
    running_path = [
        (0, 0),      # ì‹œì‘
        (100, 0),    # ë™ìª½ìœ¼ë¡œ 100m
        (100, 50),   # ë¶ìª½ìœ¼ë¡œ 50m
        (0, 50),     # ì„œìª½ìœ¼ë¡œ 100m
        (0, 0)       # ì‹œì‘ì ìœ¼ë¡œ ëŒì•„ì˜´
    ]
  
    # ë‹«íŒ ë‹¤ê°í˜•ì¸ì§€ í™•ì¸
    if is_polygon_closed(running_path):
        print("âœ… ì˜ì—­ ì™„ì„±!")
    
        # ë©´ì  ê³„ì‚°
        area = calculate_polygon_area(running_path)
        print(f"ğŸ“ ì •ë³µí•œ ë©´ì : {area:.1f} mÂ² ({area/10000:.3f} í—¥íƒ€ë¥´)")
    
        # ì ìˆ˜ ê³„ì‚° (1mÂ² = 1ì )
        score = int(area)
        print(f"ğŸ† íšë“ ì ìˆ˜: {score} ì ")
    else:
        print("âŒ ê²½ë¡œê°€ ë‹«íˆì§€ ì•ŠìŒ")
```

### ğŸ’ª ì‹¬ë°•ìˆ˜ ê¸°ë°˜ ì ìˆ˜ ì‹œìŠ¤í…œ (Python)

```python
# scoring.py - ì‹¬ë°•ìˆ˜ ê¸°ë°˜ ë™ì  ì ìˆ˜ ê³„ì‚°

from enum import Enum
from dataclasses import dataclass

class HeartRateZone(Enum):
    """ì‹¬ë°•ìˆ˜ ì¡´ (ìš´ë™ ê°•ë„)"""
    ZONE_1 = 1  # 50-60% HRmax (ë§¤ìš° ê°€ë²¼ì›€)
    ZONE_2 = 2  # 60-70% HRmax (ê°€ë²¼ì›€)
    ZONE_3 = 3  # 70-80% HRmax (ë³´í†µ)
    ZONE_4 = 4  # 80-90% HRmax (ê³ ê°•ë„)
    ZONE_5 = 5  # 90-100% HRmax (ìµœëŒ€)

@dataclass
class UserProfile:
    """ì‚¬ìš©ì í”„ë¡œí•„"""
    age: int
    resting_hr: int = 60
  
    @property
    def max_hr(self) -> int:
        """ìµœëŒ€ ì‹¬ë°•ìˆ˜ (220 - ë‚˜ì´)"""
        return 220 - self.age

def get_hr_zone(bpm: int, user: UserProfile) -> HeartRateZone:
    """í˜„ì¬ ì‹¬ë°•ìˆ˜ë¡œ ìš´ë™ ì¡´ íŒì •"""
    hr_reserve = user.max_hr - user.resting_hr
    intensity = (bpm - user.resting_hr) / hr_reserve
  
    if intensity < 0.5:
        return HeartRateZone.ZONE_1
    elif intensity < 0.6:
        return HeartRateZone.ZONE_2
    elif intensity < 0.7:
        return HeartRateZone.ZONE_3
    elif intensity < 0.8:
        return HeartRateZone.ZONE_4
    else:
        return HeartRateZone.ZONE_5

def calculate_score(base_score: float, zone: HeartRateZone) -> float:
    """ì‹¬ë°•ìˆ˜ ì¡´ì— ë”°ë¥¸ ì ìˆ˜ ë°°ìœ¨ ì ìš©"""
    multipliers = {
        HeartRateZone.ZONE_1: 0.8,
        HeartRateZone.ZONE_2: 1.0,
        HeartRateZone.ZONE_3: 1.5,
        HeartRateZone.ZONE_4: 2.0,
        HeartRateZone.ZONE_5: 2.5,
    }
    return base_score * multipliers[zone]


# ========== ì‚¬ìš© ì˜ˆì‹œ ==========
if __name__ == "__main__":
    user = UserProfile(age=25)
    print(f"ìµœëŒ€ ì‹¬ë°•ìˆ˜: {user.max_hr} bpm")
  
    # ì‹œë®¬ë ˆì´ì…˜: ë‹¤ì–‘í•œ ì‹¬ë°•ìˆ˜ì—ì„œì˜ ì ìˆ˜
    base_area_score = 5000  # 5000mÂ² ì˜ì—­ ì •ë³µ
  
    for bpm in [100, 130, 150, 170]:
        zone = get_hr_zone(bpm, user)
        final_score = calculate_score(base_area_score, zone)
        print(f"ì‹¬ë°•ìˆ˜ {bpm}bpm (Zone {zone.value}): {final_score:.0f}ì ")
```

---

## 9. ë°ì´í„° íŒŒì´í”„ë¼ì¸

### ğŸ“Š Kafka í† í”½ ì„¤ê³„

| Topic              | ë°ì´í„°                          | ë¹ˆë„               | ë³´ê´€ |
| ------------------ | ------------------------------- | ------------------ | ---- |
| `raw.gps.events` | ìœ„ë„, ê²½ë„, ì •í™•ë„, ì‹œê°„        | ~1íšŒ/ì´ˆ            | 7ì¼  |
| `raw.hr.events`  | ì‹¬ë°•ìˆ˜, RR ê°„ê²©                 | ~1íšŒ/ì´ˆ            | 7ì¼  |
| `raw.imu.events` | ê°€ì†ë„[3], ìì´ë¡œ[3], ì§€ìê¸°[3] | **~50íšŒ/ì´ˆ** | 3ì¼  |

### ğŸ’» FastAPI ë°±ì—”ë“œ ì„œë²„ (Python)

```python
# main.py - FastAPI ì„œë²„

from fastapi import FastAPI, WebSocket
from pydantic import BaseModel
from typing import List
from datetime import datetime
import asyncio

app = FastAPI(title="í—¬ìŠ¤ì¼€ì–´ ê²Œì´ë¯¸í”¼ì¼€ì´ì…˜ API")

# ë°ì´í„° ëª¨ë¸
class GPSData(BaseModel):
    user_id: str
    latitude: float
    longitude: float
    accuracy: float
    timestamp: datetime

class IMUData(BaseModel):
    user_id: str
    accel: List[float]   # [x, y, z]
    gyro: List[float]    # [x, y, z]
    timestamp: datetime

class HeartRateData(BaseModel):
    user_id: str
    bpm: int
    rr_interval: float
    timestamp: datetime

# ì›¹ì†Œì¼“ìœ¼ë¡œ ì‹¤ì‹œê°„ ìœ„ì¹˜ ìŠ¤íŠ¸ë¦¬ë°
@app.websocket("/ws/location/{user_id}")
async def location_websocket(websocket: WebSocket, user_id: str):
    await websocket.accept()
  
    while True:
        # í´ë¼ì´ì–¸íŠ¸ë¡œë¶€í„° ì„¼ì„œ ë°ì´í„° ìˆ˜ì‹ 
        data = await websocket.receive_json()
    
        # ì¹¼ë§Œ í•„í„° ì ìš© (ì‹¤ì œë¡œëŠ” EKF í´ë˜ìŠ¤ ì‚¬ìš©)
        filtered_position = {
            "x": data["gps_x"] * 0.8 + data["imu_x"] * 0.2,
            "y": data["gps_y"] * 0.8 + data["imu_y"] * 0.2,
        }
    
        # ë³´ì •ëœ ìœ„ì¹˜ ì „ì†¡
        await websocket.send_json(filtered_position)

# REST API ì—”ë“œí¬ì¸íŠ¸
@app.post("/api/v1/gps")
async def receive_gps(data: GPSData):
    # Kafkaë¡œ ì „ì†¡ (ì‹¤ì œ êµ¬í˜„ ì‹œ)
    # await kafka_producer.send("raw.gps.events", data.dict())
    return {"status": "received", "user_id": data.user_id}

@app.post("/api/v1/territory/validate")
async def validate_territory(path: List[List[float]]):
    """ê²½ë¡œê°€ ìœ íš¨í•œ ì˜ì—­ì¸ì§€ ê²€ì¦"""
    from territory import is_polygon_closed, calculate_polygon_area
  
    points = [(p[0], p[1]) for p in path]
  
    if not is_polygon_closed(points):
        return {"valid": False, "message": "ê²½ë¡œê°€ ë‹«íˆì§€ ì•ŠìŒ"}
  
    area = calculate_polygon_area(points)
    return {
        "valid": True,
        "area_m2": area,
        "score": int(area)
    }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

---

## 10. í”„ë¡œì íŠ¸ ë¡œë“œë§µ

### Phase 1: í•˜ë“œì›¨ì–´ âœ… (í˜„ì¬)

- [X] ESP32-S3 + ì„¼ì„œë“¤ ë‚©ë•œ
- [X] I2C/UART í†µì‹  êµ¬í˜„
- [X] Raw Data SDì¹´ë“œ ì €ì¥
- [X] Pythonìœ¼ë¡œ ì¹¼ë§Œ í•„í„° ì‹œë®¬ë ˆì´ì…˜

### Phase 2: ì—°ê²°ì„± ğŸ”„ (ì§„í–‰ ì¤‘)

- [ ] BLE 5.0ìœ¼ë¡œ ì•±ê³¼ í†µì‹ 
- [ ] iOS/Android ì•± ì§€ë„ ì—°ë™
- [ ] ì‹¤ì‹œê°„ ì˜ì—­ ì •ë³µ ì‹œê°í™”

### Phase 3: ë°±ì—”ë“œ ğŸ“‹ (ì˜ˆì •)

- [ ] Kafka & ì‹œê³„ì—´ DB êµ¬ì¶•
- [ ] ì‹¬ë°•ë³€ì´ë„(HRV) ë¶„ì„
- [ ] ë¦¬ë”ë³´ë“œ ì‹œìŠ¤í…œ
