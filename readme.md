# GPS & 칼만 필터 기반 헬스케어 게이미피케이션 플랫폼

운동하면서 땅따먹기! GPS와 센서로 내 위치를 정확히 추적하고, 달리면서 지도 위 영역을 정복하는 게임형 운동 앱

## 1. 프로젝트 한눈에 보기

**스마트폰 GPS는 가끔 튀어요!**

건물 옆을 지나거나, 구름이 많은 날에는 GPS가 갑자기 10미터씩 점프하기도 합니다.
이 프로젝트는 **여러 센서를 합쳐서** GPS 오차를 보정하고, 정확한 위치를 계산합니다.

### 최종 목표

```
┌─────────────────────────────────────────────────────────────────┐
│                    🏃 사용자가 달리면...                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│    📍 GPS: "지금 여기!"     →   🧮 칼만필터   →   📌 정확한 위치!     │
│    🔄 자이로: "왼쪽으로 돔"  →   (데이터 융합)  →   🗺️ 지도에 경로 표시 │  
│    📏 가속도: "앞으로 가속"  →                 →   🎮 영역 정복!      │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 왜 직접 만드나요?

| 일반적인 방법                        | 이 프로젝트                   |
| ------------------------------------ | ----------------------------- |
| 스마트폰이 주는 GPS 좌표 그대로 사용 | 센서 Raw 데이터부터 직접 처리 |
| 오차가 있어도 그냥 사용              | 칼만 필터로 오차 보정         |
| 완성된 라이브러리 사용               | 수학 공식부터 직접 구현       |

---

## 2. 기술 스택 총정리

### 📊 전체 기술 스택 다이어그램

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              기술 스택 Overview                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐         │
│  │   임베디드/펌웨어   │    │    백엔드 서버    │    │   프론트엔드/앱   │         │
│  ├─────────────────┤    ├─────────────────┤    ├─────────────────┤         │
│  │ • C/C++         │    │ • Python        │    │ • React Native  │         │
│  │ • ESP-IDF       │    │ • FastAPI       │    │ • TypeScript    │         │
│  │ • FreeRTOS      │    │ • Kafka         │    │ • Mapbox GL     │         │
│  │ • Arduino       │    │ • TimescaleDB   │    │                 │         │
│  └────────┬────────┘    └────────┬────────┘    └────────┬────────┘         │
│           │                      │                      │                   │
│           └──────────────────────┼──────────────────────┘                   │
│                                  ▼                                          │
│                        ┌─────────────────┐                                  │
│                        │   데이터 분석     │                                  │
│                        ├─────────────────┤                                  │
│                        │ • Python        │                                  │
│                        │ • NumPy/SciPy   │                                  │
│                        │ • Matplotlib    │                                  │
│                        └─────────────────┘                                  │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 🛠️ 레이어별 기술 스택

| 레이어               | 기술         | 버전      | 용도                   |
| -------------------- | ------------ | --------- | ---------------------- |
| **임베디드**   | C/C++        | C11/C++17 | ESP32 펌웨어 개발      |
|                      | ESP-IDF      | v5.1      | 공식 개발 프레임워크   |
|                      | FreeRTOS     | -         | 실시간 멀티태스킹      |
|                      | Arduino      | -         | 빠른 프로토타이핑용    |
| **통신**       | BLE 5.0      | -         | 디바이스 ↔ 앱 통신    |
|                      | I2C          | -         | 센서 ↔ MCU 통신       |
|                      | UART         | -         | GPS ↔ MCU 통신        |
| **백엔드**     | Python       | 3.11+     | 메인 언어              |
|                      | FastAPI      | 0.100+    | REST API 서버          |
|                      | Kafka        | 3.5+      | 실시간 메시지 스트리밍 |
|                      | TimescaleDB  | 2.11+     | 시계열 데이터 저장     |
| **프론트엔드** | React Native | 0.72+     | 크로스플랫폼 앱        |
|                      | TypeScript   | 5.0+      | 타입 안정성            |
|                      | Mapbox GL    | 10.0+     | 지도 시각화            |
| **분석**       | NumPy        | 1.24+     | 수치 계산              |
|                      | SciPy        | 1.11+     | 칼만 필터 구현         |
|                      | Matplotlib   | 3.7+      | 데이터 시각화          |

---

## 3. 시스템 전체 구조

### 📊 데이터가 흐르는 길

```
  [손목에 찬 웨어러블 기기]
         │
         ▼
  ┌──────────────────────────────────────────────────────────────┐
  │                    센서들 (3가지)                              │
  │                                                              │
  │   🛰️ GPS 모듈        🔄 IMU 센서           ❤️ 심박 센서         │
  │   (NEO-M9N)         (MPU-9250)           (MAX30102)         │
  │   "위도/경도 알려줌"   "흔들림/회전 감지"      "심장 박동 측정"     │
  │        │ UART              │ I2C                │ I2C        │
  └────────┼──────────────────┼────────────────────┼─────────────┘
           │                  │                    │
           ▼                  ▼                    ▼
  ┌──────────────────────────────────────────────────────────────┐
  │                   🧠 ESP32-S3 (두뇌)                          │
  │                                                              │
  │   [Step 1] Raw 데이터 수집 (0xFF, 0xAD 같은 숫자들)              │
  │       ↓                                                      │
  │   [Step 2] 물리 단위로 변환 (-0.05 m/s² 같은 의미있는 값)         │
  │       ↓                                                      │
  │   [Step 3] 칼만 필터 적용 (위치/속도/방향 추정)                   │
  │       ↓                                                      │
  │   [Step 4] 게임 로직 (영역 정복 계산)                           │
  │                                                              │
  └───────────────────────────┬──────────────────────────────────┘
                              │
              ┌───────────────┼───────────────┐
              ▼                               ▼
     📱 스마트폰 앱                      💾 SD 카드
     (지도에 표시)                      (데이터 저장)
```

---

## 3.1 🔄 완전한 데이터 흐름도 (Raw → 최종 출력)

**센서에서 읽은 Raw 데이터가 어떻게 "정복한 영역 5,000점!"이 되는지** 전체 과정을 따라가봅시다.

### 📊 전체 파이프라인 다이어그램

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                         🔄 완전한 데이터 흐름 (End-to-End)                              │
├─────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                     │
│  ① 센서 Raw 데이터 수집                                                               │
│  ─────────────────────────────────────────────────────────────────────────────────  │
│                                                                                     │
│   🛰️ GPS (UART)              🔄 IMU (I2C)                 ❤️ 심박 (I2C)               │
│   ┌──────────────────┐      ┌──────────────────┐        ┌──────────────────┐       │
│   │ "$GPGGA,092750.  │      │ 0x3B: 0xFF       │        │ IR:  50213       │       │
│   │ 000,3723.4657,N, │      │ 0x3C: 0xAD       │        │ Red: 48123       │       │
│   │ 12202.2694,W..." │      │ 0x3D: 0x00 ...   │        │ (PPG 파형)        │       │
│   └────────┬─────────┘      └────────┬─────────┘        └────────┬─────────┘       │
│            │                         │                           │                  │
│            ▼                         ▼                           ▼                  │
│  ② 파싱 & 물리 단위 변환                                                              │
│  ─────────────────────────────────────────────────────────────────────────────────  │
│                                                                                     │
│   📍 위경도 추출              ⚡ Raw → 물리량              💓 피크 검출               │
│   ┌──────────────────┐      ┌──────────────────┐        ┌──────────────────┐       │
│   │ lat: 37.390762°  │      │ ax: -0.0497 m/s² │        │ BPM: 145         │       │
│   │ lon: 122.037823° │      │ ay:  0.1197 m/s² │        │ RR: 0.41초        │       │
│   │ HDOP: 1.03       │      │ ωz:  0.0999 rad/s│        │ Zone: 4          │       │
│   └────────┬─────────┘      └────────┬─────────┘        └────────┬─────────┘       │
│            │                         │                           │                  │
│            ▼                         ▼                           │                  │
│  ③ 좌표 변환                  ④ 칼만 필터                        │                  │
│  ─────────────────────────────────────────────────────────────────────────────────  │
│                                                                                     │
│   🗺️ 위경도 → 미터            🧮 센서 융합 (EKF)                                      │
│   ┌──────────────────┐      ┌──────────────────┐                                   │
│   │ GPS 측정값 (z):   │ ──→  │ 상태 추정:        │                                   │
│   │ x_gps: 15.3 m    │      │ px: 15.01 m     │   ← 보정된 위치!                   │
│   │ y_gps:  5.1 m    │      │ py:  5.00 m     │                                   │
│   └──────────────────┘      │ vx:  1.50 m/s   │                                   │
│                             │ vy:  0.50 m/s   │                                   │
│   입력값 (u):                │ θ:  0.057 rad   │                                   │
│   ┌──────────────────┐      └────────┬─────────┘                                   │
│   │ ax, ay (가속도)   │ ──→          │                                             │
│   │ ωz (각속도)       │              │                                             │
│   └──────────────────┘              │                                             │
│                                     ▼                                             │
│  ⑤ 게임 로직                                                                        │
│  ─────────────────────────────────────────────────────────────────────────────────  │
│                                                                                     │
│   🎮 영역 정복 판정                                                                  │
│   ┌────────────────────────────────────────────────────────────────┐              │
│   │                                                                │              │
│   │   경로 좌표들: [(0,0), (100,0), (100,50), (0,50), (0,0)]         │              │
│   │                          │                                      │              │
│   │                          ▼                                      │              │
│   │   닫힌 다각형? ─── YES ──→ 면적 계산: 5,000 m²                    │              │
│   │                          │                                      │              │
│   │                          ▼                                      │              │
│   │   점수 = 면적 × 심박존 배율                                        │ ←────────┐  │
│   │        = 5,000 × 2.0 (Zone 4)                                   │          │  │
│   │        = 10,000 점! 🎉                                          │    심박 Zone │
│   │                                                                │              │
│   └────────────────────────────────────────────────────────────────┘              │
│                                                                                     │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

### 📋 데이터 변환 요약표

| 단계 | GPS 데이터 | IMU 데이터 | 심박 데이터 |
|------|-----------|-----------|------------|
| **① Raw** | `"$GPGGA,3723.4657,N..."` (문자열) | `0xFF, 0xAD` (16bit 정수) | `IR: 50213` (PPG 파형) |
| **② 파싱** | 위도: `37.390762°` <br> 경도: `122.037823°` | ACCEL_X: `-83` <br> GYRO_Z: `750` | 피크 간격 검출 |
| **③ 물리량** | HDOP: `1.03` (정확도) | ax: `-0.0497 m/s²` <br> ωz: `0.0999 rad/s` | BPM: `145` <br> Zone: `4` |
| **④ 좌표변환** | x: `15.3 m`, y: `5.1 m` (로컬 좌표) | - | - |
| **⑤ 칼만필터** | 측정값 z로 사용 | 입력값 u로 사용 | - |
| **⑥ 출력** | px: `15.01 m` (보정된 위치) | vx: `1.50 m/s`, θ: `0.057 rad` | 점수 배율: `×2.0` |
| **⑦ 최종** | 🎮 닫힌 경로 → 면적: `5,000 m²` → 점수: **`10,000점`** |

---

## 4. 하드웨어 구성

### 🧩 사용하는 부품들

| 부품                 | 모델명      | 하는 일                          | 연결 방식          |
| -------------------- | ----------- | -------------------------------- | ------------------ |
| **두뇌 (MCU)** | ESP32-S3    | 모든 계산을 담당하는 소형 컴퓨터 | -                  |
| **GPS**        | NEO-M9N     | 위성에서 신호 받아 위치 계산     | UART (문자로 대화) |
| **IMU**        | MPU-9250    | 움직임 감지 (가속도+회전+나침반) | I2C (번호로 대화)  |
| **심박**       | MAX30102    | 손목 혈관에 빛 쏴서 맥박 측정    | I2C                |
| **배터리**     | LiPo 500mAh | 전원 공급 (3.7V)                 | -                  |

### 🔋 전원 문제

```
배터리: 3.7V  →  그런데 MCU는 3.3V만 받음!  →  레귤레이터로 전압 낮춤
         ⚡                  ⚠️                     ✅
```

### 📌 핀 연결도 (Wiring Diagram)

```
ESP32-S3 핀 배치:
┌─────────────────────────────────────┐
│                ESP32-S3             │
│                                     │
│  GPIO 21 (SDA) ────┬──── MPU-9250 SDA
│  GPIO 22 (SCL) ────┼──── MPU-9250 SCL
│                    │
│                    ├──── MAX30102 SDA
│                    └──── MAX30102 SCL
│                                     │
│  GPIO 16 (RX) ────────── NEO-M9N TX │
│  GPIO 17 (TX) ────────── NEO-M9N RX │
│                                     │
│  3.3V ─────────────────── 센서 VCC  │
│  GND ──────────────────── 센서 GND  │
└─────────────────────────────────────┘
```

---

## 5. Step 1: 센서 데이터 읽기

### 🤔 센서가 보내는 데이터는 어떻게 생겼나요?

센서는 우리가 아는 "10미터", "5도" 같은 숫자가 아니라, **2진수 데이터**를 보냅니다!

### 📟 GPS가 보내는 데이터 예시

GPS는 **NMEA**라는 형식의 문자열을 보냅니다:

```
$GPGGA,092750.000,3723.4657,N,12202.2694,W,1,8,1.03,61.7,M,-21.3,M,,*5C
  │       │          │     │      │     │ │ │  │    │
  │       │          │     │      │     │ │ │  │    └─ 해발 고도
  │       │          │     │      │     │ │ │  └────── 정확도
  │       │          │     │      │     │ │ └──────── 위성 개수
  │       │          │     │      │     │ └────────── GPS 품질
  │       │          │     │      └─────┴──────────── 경도 (서경)
  │       │          └─────┴───────────────────────── 위도 (북위)
  │       └────────────────────────────────────────── 시간
  └────────────────────────────────────────────────── 데이터 종류
```

### 💻 GPS 파싱 코드 (C언어 - ESP32)

```c
// gps_parser.c - GPS NMEA 문자열 파싱

#include <string.h>
#include <stdlib.h>

typedef struct {
    double latitude;      // 위도
    double longitude;     // 경도
    float altitude;       // 고도
    int satellites;       // 위성 수
    float hdop;          // 정확도
    char lat_dir;        // 위도 방향 (N/S)  ← 추가!
    char lon_dir;        // 경도 방향 (E/W)  ← 추가!
} GPSData;

// NMEA 문자열에서 GPS 데이터 추출
bool parse_gpgga(const char* nmea, GPSData* gps) {
    // $GPGGA 로 시작하는지 확인
    if (strncmp(nmea, "$GPGGA", 6) != 0) {
        return false;
    }
  
    char* token;
    char buffer[100];
    strcpy(buffer, nmea);
  
    int field = 0;
    token = strtok(buffer, ",");
  
    while (token != NULL) {
        switch (field) {
            case 2:  // 위도 (3723.4657)
                gps->latitude = atof(token);
                // DDMM.MMMM → DD.DDDDDD 변환
                int deg = (int)(gps->latitude / 100);
                double min = gps->latitude - (deg * 100);
                gps->latitude = deg + (min / 60.0);
                break;
            
            case 3:  // 위도 방향 (N/S) ← 추가!
                gps->lat_dir = token[0];
                // ⚠️ 남반구면 음수로!
                if (gps->lat_dir == 'S') {
                    gps->latitude = -gps->latitude;
                }
                break;
            
            case 4:  // 경도 (12202.2694)
                gps->longitude = atof(token);
                deg = (int)(gps->longitude / 100);
                min = gps->longitude - (deg * 100);
                gps->longitude = deg + (min / 60.0);
                break;
            
            case 5:  // 경도 방향 (E/W) ← 추가!
                gps->lon_dir = token[0];
                // ⚠️ 서경이면 음수로!
                if (gps->lon_dir == 'W') {
                    gps->longitude = -gps->longitude;
                }
                break;
            
            case 7:  // 위성 수
                gps->satellites = atoi(token);
                break;
            
            case 8:  // HDOP (정확도)
                gps->hdop = atof(token);
                break;
            
            case 9:  // 고도
                gps->altitude = atof(token);
                break;
        }
        token = strtok(NULL, ",");
        field++;
    }
  
    return true;
}

// 사용 예시
void read_gps_example() {
    const char* nmea = "$GPGGA,092750.000,3723.4657,N,12202.2694,W,1,8,1.03,61.7,M,,*5C";
    GPSData gps;
  
    if (parse_gpgga(nmea, &gps)) {
        printf("위도: %.6f (방향: %c)\n", gps.latitude, gps.lat_dir);   // 37.390762 (N)
        printf("경도: %.6f (방향: %c)\n", gps.longitude, gps.lon_dir); // -122.037823 (W) ← 음수!
        printf("위성 수: %d\n", gps.satellites);     // 8
    }
}
```

### 🗺️ GPS 좌표 → 미터 변환 (중요!)

**칼만 필터는 "미터" 단위로 계산합니다!**

GPS가 주는 위도/경도(도 단위)를 그대로 사용할 수 없어요. 왜냐하면:
- 위도 1도 ≈ 111km (지구 둘레 ÷ 360)
- 경도 1도 ≈ 111km × cos(위도) (적도에서 멀어질수록 짧아짐)

**칼만 필터에 넣으려면 미터로 바꿔야 합니다!**

```
┌────────────────────────────────────────────────────────────────────┐
│  🌍 위경도 → 로컬 XY 좌표 변환 원리                                    │
├────────────────────────────────────────────────────────────────────┤
│                                                                    │
│   지구를 펼치면...              로컬 좌표계로 변환                     │
│                                                                    │
│   ▲ 위도 (lat)                 ▲ Y (미터)                          │
│   │                            │                                   │
│   │    ●현재위치                │    ●(0, 0) 기준점                  │
│   │    │                       │         │                         │
│   │    │← Δlat                 │         │← Δy (미터)              │
│   │    ▼                       │         ▼                         │
│   │    ○시작점                  │         ○                         │
│   └──────────▶ 경도 (lon)      └──────────▶ X (미터)                │
│         Δlon                          Δx (미터)                     │
│                                                                    │
│   📐 변환 공식:                                                      │
│   ─────────────────────────────────────────────────────────────   │
│   Δx = (lon₂ - lon₁) × cos(lat) × 111,320 m                       │
│   Δy = (lat₂ - lat₁) × 111,320 m                                  │
│                                                                    │
│   ※ 111,320 = 지구 둘레(40,075km) ÷ 360°                           │
│   ※ cos(lat)는 위도가 높아질수록 경도 1도의 거리가 줄어드는 것을 보정     │
│                                                                    │
└────────────────────────────────────────────────────────────────────┘
```

### 💻 GPS → 미터 변환 코드 (C언어)

```c
// gps_to_meters.c - 위경도를 로컬 미터 좌표로 변환

#include <math.h>

#define EARTH_RADIUS_M  6371000.0   // 지구 반지름 (미터)
#define DEG_TO_RAD      (M_PI / 180.0)
#define METERS_PER_DEG  111320.0    // 위도 1도 ≈ 111.32km

typedef struct {
    double x;   // X 좌표 (동쪽 +, 서쪽 -)
    double y;   // Y 좌표 (북쪽 +, 남쪽 -)
} LocalPosition;

// 기준점 (앱 시작 시 첫 GPS 좌표)
typedef struct {
    double ref_lat;     // 기준 위도
    double ref_lon;     // 기준 경도
    double cos_ref_lat; // cos(기준위도) - 미리 계산해두면 빠름!
} GPSReference;

// 기준점 초기화 (앱 시작 시 한 번 호출)
void init_gps_reference(GPSReference* ref, double lat, double lon) {
    ref->ref_lat = lat;
    ref->ref_lon = lon;
    ref->cos_ref_lat = cos(lat * DEG_TO_RAD);  // 미리 계산!
}

// 위경도 → 로컬 미터 좌표 변환
LocalPosition gps_to_local(const GPSReference* ref, double lat, double lon) {
    LocalPosition pos;
    
    // 경도 차이 → X (미터)
    // ⚠️ cos(위도) 보정 필수! (적도에서 멀어질수록 경도 간격이 좁아짐)
    pos.x = (lon - ref->ref_lon) * ref->cos_ref_lat * METERS_PER_DEG;
    
    // 위도 차이 → Y (미터)
    pos.y = (lat - ref->ref_lat) * METERS_PER_DEG;
    
    return pos;
}

// 사용 예시
void gps_conversion_example() {
    GPSReference ref;
    
    // 1. 기준점 설정 (운동 시작 위치)
    init_gps_reference(&ref, 37.390762, -122.037823);
    
    // 2. 이동 후 GPS 좌표
    double new_lat = 37.390852;   // 북쪽으로 약 10m 이동
    double new_lon = -122.037723; // 동쪽으로 약 8m 이동
    
    // 3. 미터 좌표로 변환
    LocalPosition pos = gps_to_local(&ref, new_lat, new_lon);
    
    printf("현재 위치: X=%.2f m, Y=%.2f m\n", pos.x, pos.y);
    // 출력: 현재 위치: X=7.93 m, Y=10.02 m
}
```

### 🧮 변환 계산 예시 (손으로 계산해보기)

```
┌────────────────────────────────────────────────────────────────────┐
│  📍 예시: 서울에서 10미터 북쪽으로 이동하면?                            │
├────────────────────────────────────────────────────────────────────┤
│                                                                    │
│   기준점: (위도 37.5°, 경도 127.0°)                                  │
│   이동 후: (위도 37.50009°, 경도 127.0°)                             │
│                                                                    │
│   계산:                                                             │
│   ──────                                                           │
│   Δlat = 37.50009 - 37.5 = 0.00009°                                │
│   Δy = 0.00009 × 111,320 = 10.02 m ✅                              │
│                                                                    │
│   역으로, 10m 이동 시 위도 변화:                                      │
│   Δlat = 10 ÷ 111,320 = 0.0000899° ≈ 0.00009°                      │
│                                                                    │
└────────────────────────────────────────────────────────────────────┘
```

### 🔢 IMU가 보내는 데이터 예시

MPU-9250 센서는 **I2C 통신**으로 16진수 데이터를 보냅니다:

```
주소      이름           값 (16진수)    값 (2진수)
────────────────────────────────────────────────────
0x3B   ACCEL_X 상위    0xFF          1111 1111
0x3C   ACCEL_X 하위    0xAD          1010 1101
        └─────────────────────────────────────────→ 합치면: -83 (음수!)

0x3D   ACCEL_Y 상위    0x00          0000 0000  
0x3E   ACCEL_Y 하위    0xC8          1100 1000
        └─────────────────────────────────────────→ 합치면: 200 (양수!)

0x3F   ACCEL_Z 상위    0x40          0100 0000
0x40   ACCEL_Z 하위    0x74          0111 0100
        └─────────────────────────────────────────→ 합치면: 16,500 (약 1g!)
```

### 💻 IMU 읽기 코드 (C언어 - ESP32)

```c
// mpu9250.c - MPU-9250 센서 데이터 읽기

#include "driver/i2c.h"

#define MPU9250_ADDR    0x68    // I2C 주소
#define ACCEL_XOUT_H    0x3B    // 가속도 X 상위 바이트 레지스터

typedef struct {
    int16_t accel_x;    // X축 가속도 (Raw)
    int16_t accel_y;    // Y축 가속도 (Raw)
    int16_t accel_z;    // Z축 가속도 (Raw)
    int16_t gyro_x;     // X축 자이로 (Raw)
    int16_t gyro_y;     // Y축 자이로 (Raw)
    int16_t gyro_z;     // Z축 자이로 (Raw)
} IMURawData;

// I2C로 1바이트 읽기
uint8_t i2c_read_byte(uint8_t addr, uint8_t reg) {
    uint8_t data;
    i2c_master_write_read_device(I2C_NUM_0, addr, &reg, 1, &data, 1, 100);
    return data;
}

// MPU-9250에서 Raw 데이터 읽기
void mpu9250_read_raw(IMURawData* data) {
    uint8_t buffer[14];  // 가속도 6바이트 + 온도 2바이트 + 자이로 6바이트
  
    // 0x3B부터 14바이트 연속 읽기
    uint8_t reg = ACCEL_XOUT_H;
    i2c_master_write_read_device(I2C_NUM_0, MPU9250_ADDR, &reg, 1, buffer, 14, 100);
  
    // 상위/하위 바이트 결합 (Big Endian → int16_t)
    data->accel_x = (buffer[0] << 8) | buffer[1];   // 0x3B, 0x3C
    data->accel_y = (buffer[2] << 8) | buffer[3];   // 0x3D, 0x3E
    data->accel_z = (buffer[4] << 8) | buffer[5];   // 0x3F, 0x40
    // buffer[6], buffer[7] = 온도 (생략)
    data->gyro_x  = (buffer[8] << 8) | buffer[9];   // 0x43, 0x44
    data->gyro_y  = (buffer[10] << 8) | buffer[11]; // 0x45, 0x46
    data->gyro_z  = (buffer[12] << 8) | buffer[13]; // 0x47, 0x48
}

// 사용 예시
void read_imu_example() {
    IMURawData raw;
    mpu9250_read_raw(&raw);
  
    printf("ACCEL_X Raw: %d\n", raw.accel_x);  // -83
    printf("ACCEL_Y Raw: %d\n", raw.accel_y);  // 200
    printf("ACCEL_Z Raw: %d\n", raw.accel_z);  // 16500
    printf("GYRO_Z Raw: %d\n", raw.gyro_z);    // 750
}
```

### 🎓 왜 음수가 나오나요? (2의 보수)

```
예시: 0xFFAD가 왜 -83인가?

1. 16진수 → 2진수:  1111 1111 1010 1101
2. 맨 앞이 1이면 음수!
3. 비트 뒤집기:     0000 0000 0101 0010
4. +1 하기:         0000 0000 0101 0011 = 83
5. 결과: -83
```

### ✅ Step 1 결과

| 센서    | Raw 값           | 의미                  |
| ------- | ---------------- | --------------------- |
| ACCEL_X | **-83**    | 살짝 뒤로 가속 (감속) |
| ACCEL_Y | **200**    | 오른쪽으로 기울어짐   |
| ACCEL_Z | **16,500** | 중력 (≈1g)           |
| GYRO_Z  | **750**    | 왼쪽으로 회전 중      |

---

## 5.1 🔧 IMU 캘리브레이션 (바이어스 보정)

### 🤔 왜 캘리브레이션이 필요한가요?

**센서는 완벽하지 않아요!** 😅

가만히 놔둬도 자이로스코프가 조금씩 값을 내보내요. 이걸 **바이어스(Bias)**라고 합니다.

```
┌────────────────────────────────────────────────────────────────────┐
│  🔧 센서 바이어스 문제                                               │
├────────────────────────────────────────────────────────────────────┤
│                                                                    │
│   예상 (정지 상태):              실제:                              │
│   ┌─────────────────┐          ┌─────────────────┐                │
│   │ GYRO_X = 0      │          │ GYRO_X = 15     │  ← 오차!       │
│   │ GYRO_Y = 0      │    VS    │ GYRO_Y = -23    │  ← 오차!       │
│   │ GYRO_Z = 0      │          │ GYRO_Z = 8      │  ← 오차!       │
│   └─────────────────┘          └─────────────────┘                │
│                                                                    │
│   이 오차가 누적되면...                                              │
│   1초 후: 8°                                                       │
│   1분 후: 480° (1바퀴 반?!)                                        │
│                                                                    │
│   💡 해결책: 시작 시 바이어스 측정 후 빼주기!                          │
│                                                                    │
└────────────────────────────────────────────────────────────────────┘
```

### 💻 캘리브레이션 코드 (C언어)

```c
// imu_calibration.c - IMU 바이어스 캘리브레이션

#define CALIBRATION_SAMPLES 1000  // 10초간 (100Hz × 10초)

typedef struct {
    // 자이로스코프 바이어스 (정지 상태에서도 나오는 값)
    float gyro_bias_x;
    float gyro_bias_y;
    float gyro_bias_z;
    
    // 가속도계 바이어스 (중력 제외한 오차)
    float accel_bias_x;
    float accel_bias_y;
    float accel_bias_z;
    
    bool is_calibrated;   // 캘리브레이션 완료 여부
} IMUCalibration;

// 캘리브레이션 수행 (디바이스를 수평으로 놓고 가만히!)
bool calibrate_imu(IMUCalibration* cal) {
    printf("⏳ 캘리브레이션 시작! 디바이스를 수평으로 놓고 10초간 움직이지 마세요...\n");
    
    // 합계 누적용
    long gyro_sum[3] = {0, 0, 0};
    long accel_sum[3] = {0, 0, 0};
    
    IMURawData raw;
    
    for (int i = 0; i < CALIBRATION_SAMPLES; i++) {
        mpu9250_read_raw(&raw);
        
        gyro_sum[0] += raw.gyro_x;
        gyro_sum[1] += raw.gyro_y;
        gyro_sum[2] += raw.gyro_z;
        
        accel_sum[0] += raw.accel_x;
        accel_sum[1] += raw.accel_y;
        accel_sum[2] += raw.accel_z;
        
        vTaskDelay(pdMS_TO_TICKS(10));  // 100Hz (10ms 대기)
    }
    
    // 평균 계산 = 바이어스
    cal->gyro_bias_x = (float)gyro_sum[0] / CALIBRATION_SAMPLES;
    cal->gyro_bias_y = (float)gyro_sum[1] / CALIBRATION_SAMPLES;
    cal->gyro_bias_z = (float)gyro_sum[2] / CALIBRATION_SAMPLES;
    
    // 가속도계: 수평 상태에서 Z축만 중력(16384)이어야 함
    cal->accel_bias_x = (float)accel_sum[0] / CALIBRATION_SAMPLES;
    cal->accel_bias_y = (float)accel_sum[1] / CALIBRATION_SAMPLES;
    cal->accel_bias_z = (float)accel_sum[2] / CALIBRATION_SAMPLES - 16384.0f;  // 중력 빼기!
    
    cal->is_calibrated = true;
    
    printf("✅ 캘리브레이션 완료!\n");
    printf("   자이로 바이어스: (%.1f, %.1f, %.1f)\n", 
           cal->gyro_bias_x, cal->gyro_bias_y, cal->gyro_bias_z);
    printf("   가속도 바이어스: (%.1f, %.1f, %.1f)\n",
           cal->accel_bias_x, cal->accel_bias_y, cal->accel_bias_z);
    
    return true;
}

// 바이어스 보정된 데이터 읽기
void read_calibrated_imu(const IMUCalibration* cal, IMURawData* raw) {
    mpu9250_read_raw(raw);
    
    if (cal->is_calibrated) {
        // ⚠️ 바이어스 빼기! (정수 연산)
        raw->gyro_x -= (int16_t)cal->gyro_bias_x;
        raw->gyro_y -= (int16_t)cal->gyro_bias_y;
        raw->gyro_z -= (int16_t)cal->gyro_bias_z;
        
        raw->accel_x -= (int16_t)cal->accel_bias_x;
        raw->accel_y -= (int16_t)cal->accel_bias_y;
        raw->accel_z -= (int16_t)cal->accel_bias_z;
    }
}

// 사용 예시
void calibration_example() {
    IMUCalibration cal;
    
    // 1. 앱 시작 시 캘리브레이션
    calibrate_imu(&cal);
    
    // 2. 이후 데이터 읽기
    IMURawData raw;
    read_calibrated_imu(&cal, &raw);
    
    printf("보정된 GYRO_Z: %d (바이어스 제거됨!)\n", raw.gyro_z);
}
```

### 📊 캘리브레이션 전후 비교

| 항목 | 캘리브레이션 전 | 캘리브레이션 후 |
|------|---------------|---------------|
| GYRO_X (정지) | 15 | **0** ✓ |
| GYRO_Y (정지) | -23 | **0** ✓ |
| GYRO_Z (정지) | 8 | **0** ✓ |
| 1분 후 누적 오차 | 480° 🔴 | **0°** ✅ |

---

## 6. Step 2: 물리 단위 변환

### 🤔 왜 변환이 필요한가요?

**-83**이라는 숫자만 봐서는 "얼마나 빨리 가속하는지" 알 수 없어요!
이 숫자를 **m/s²** (미터/초²) 같은 **물리 단위**로 바꿔야 계산이 가능합니다.

### 📐 변환 공식 (가속도)

```
                    Raw 값
실제 가속도 = ─────────────── × 중력가속도(9.8)
               Sensitivity
```

**Sensitivity(민감도)란?**

- ±2g 모드: 1g = 16,384
- 즉, 센서값 16,384가 나오면 = 1g = 9.8 m/s²

### 💻 단위 변환 코드 (C언어 - ESP32)

```c
// sensor_convert.c - Raw 데이터를 물리 단위로 변환

#include <math.h>

// 상수 정의 (미리 계산해두면 CPU 절약!)
#define ACCEL_SENSITIVITY   16384.0f    // ±2g 모드
#define GYRO_SENSITIVITY    131.0f      // ±250°/s 모드
#define GRAVITY             9.80665f    // 표준 중력 가속도
#define DEG_TO_RAD          (M_PI / 180.0f)

// 최적화된 스케일 팩터 (나눗셈 대신 곱셈 사용)
#define ACCEL_SCALE     (GRAVITY / ACCEL_SENSITIVITY)    // 0.000598550
#define GYRO_SCALE      (DEG_TO_RAD / GYRO_SENSITIVITY)  // 0.000133158

typedef struct {
    float accel_x;    // m/s²
    float accel_y;    // m/s²
    float accel_z;    // m/s²
    float gyro_x;     // rad/s
    float gyro_y;     // rad/s
    float gyro_z;     // rad/s
} IMUPhysicalData;

// Raw → 물리 단위 변환
void convert_imu_data(const IMURawData* raw, IMUPhysicalData* phys) {
    // 가속도 변환: Raw → m/s²
    phys->accel_x = raw->accel_x * ACCEL_SCALE;
    phys->accel_y = raw->accel_y * ACCEL_SCALE;
    phys->accel_z = raw->accel_z * ACCEL_SCALE;
  
    // 자이로 변환: Raw → rad/s
    phys->gyro_x = raw->gyro_x * GYRO_SCALE;
    phys->gyro_y = raw->gyro_y * GYRO_SCALE;
    phys->gyro_z = raw->gyro_z * GYRO_SCALE;
}

// 사용 예시
void convert_example() {
    IMURawData raw = {-83, 200, 16500, 0, 0, 750};
    IMUPhysicalData phys;
  
    convert_imu_data(&raw, &phys);
  
    printf("가속도 X: %.4f m/s²\n", phys.accel_x);  // -0.0497
    printf("가속도 Y: %.4f m/s²\n", phys.accel_y);  //  0.1197
    printf("가속도 Z: %.4f m/s²\n", phys.accel_z);  //  9.8770 (≈1g)
    printf("각속도 Z: %.4f rad/s\n", phys.gyro_z);   //  0.0999
}
```

### 🧮 ACCEL_X 계산 예시 (수동 계산)

```
┌────────────────────────────────────────────────────────────────┐
│  ACCEL_X = -83 을 m/s² 로 변환                                  │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  Step 1: g 단위로 변환                                          │
│  ─────────────────────                                         │
│      -83 ÷ 16,384 = -0.00507 g                                 │
│                                                                │
│  Step 2: m/s² 로 변환                                           │
│  ──────────────────                                            │
│      -0.00507 × 9.80665 = -0.0497 m/s²                         │
│                                                                │
│  결과: 뒤쪽으로 0.0497 m/s² 가속 (아주 살짝 감속 중)               │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

### ✅ Step 2 결과: 입력 벡터 $u_k$

```
         ┌───────────────┐
         │  ax = -0.0497 │ ← X축 가속도 (m/s²)
  u_k =  │  ay =  0.1197 │ ← Y축 가속도 (m/s²)  
         │  ωz =  0.0999 │ ← Z축 각속도 (rad/s)
         └───────────────┘
```

---

## 7. Step 3: 칼만 필터 계산

### 🤔 칼만 필터가 뭔가요?

**GPS는 가끔 거짓말을 해요!** 😅

- GPS: "너 지금 여기!" (실제로는 5m 옆)
- 센서: "근데 너 방금 앞으로만 갔잖아?"
- 칼만 필터: "둘 다 참고해서... 아마 진짜 위치는 여기일 거야!"

**칼만 필터 = 여러 정보를 종합해서 가장 그럴듯한 값을 추정하는 수학적 방법**

### 🎯 상태 벡터 (우리가 알고 싶은 것들)

```
         ┌─────┐
         │ px  │ ← X 위치 (어디에 있나?)
         │ py  │ ← Y 위치
  x  =   │ vx  │ ← X 속도 (얼마나 빨리 가나?)
         │ vy  │ ← Y 속도
         │ θ   │ ← 방향 (어디를 보고 있나?)
         └─────┘
```

---

## 7.1 📐 칼만 필터 수학 완전 정복

### 🔄 칼만 필터의 두 단계

칼만 필터는 **예측(Predict)**과 **보정(Update)** 두 단계를 반복합니다.

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                         🔄 칼만 필터 동작 원리                                         │
├─────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                     │
│   ┌───────────────────────────────┐      ┌───────────────────────────────┐         │
│   │      1️⃣ 예측 (Predict)          │      │      2️⃣ 보정 (Update)          │         │
│   ├───────────────────────────────┤      ├───────────────────────────────┤         │
│   │                               │      │                               │         │
│   │  "지금 속도면 다음엔 여기겠지?"    │      │  "근데 GPS가 저기라고 하네..."    │         │
│   │                               │      │                               │         │
│   │  입력:                         │      │  입력:                         │         │
│   │  • 이전 상태 (x_{k-1})          │      │  • 예측된 상태                   │         │
│   │  • 가속도/각속도 (u_k)           │      │  • GPS 측정값 (z_k)             │         │
│   │                               │      │                               │         │
│   │  출력:                         │  →   │  출력:                         │         │
│   │  • 예측된 상태 (x̂_{k|k-1})      │      │  • 보정된 상태 (x̂_k)            │         │
│   │  • 예측된 불확실성 (P_{k|k-1})   │      │  • 보정된 불확실성 (P_k)         │         │
│   │                               │      │                               │         │
│   └───────────────────────────────┘      └───────────────────────────────┘         │
│                                                                                     │
│   🔁 이 과정을 매 순간(0.01초) 반복!                                                  │
│                                                                                     │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

### 📝 Step 1: 예측 단계 수학 공식

**상태 전이 방정식** (등가속도 운동 공식):

```
┌────────────────────────────────────────────────────────────────────┐
│  📐 예측 방정식 (Prediction Equations)                               │
├────────────────────────────────────────────────────────────────────┤
│                                                                    │
│  1. 위치 예측 (등가속도 운동)                                        │
│  ────────────────────────────                                      │
│     px_k = px_{k-1} + vx·Δt + ½·ax_global·Δt²                      │
│     py_k = py_{k-1} + vy·Δt + ½·ay_global·Δt²                      │
│                                                                    │
│  2. 속도 예측                                                       │
│  ────────────────────────────                                      │
│     vx_k = vx_{k-1} + ax_global·Δt                                 │
│     vy_k = vy_{k-1} + ay_global·Δt                                 │
│                                                                    │
│  3. 방향 예측                                                       │
│  ────────────────────────────                                      │
│     θ_k = θ_{k-1} + ωz·Δt                                          │
│                                                                    │
│  ※ Δt = 0.01초 (100Hz 샘플링)                                       │
│                                                                    │
└────────────────────────────────────────────────────────────────────┘
```

### 🔄 좌표 회전 변환 (Body → Global)

**왜 필요한가요?**

센서가 측정하는 가속도는 **기기 기준(Body Frame)**입니다.
하지만 우리가 원하는 건 **세계 기준(Global Frame)** 좌표입니다!

```
┌────────────────────────────────────────────────────────────────────┐
│  🔄 좌표 회전 변환                                                   │
├────────────────────────────────────────────────────────────────────┤
│                                                                    │
│   기기가 45° 회전해있다면?                                           │
│                                                                    │
│        Y (Global)                 Y (Body)                         │
│          ▲                            ▲                            │
│          │    ╱ Body               ╲  │  ╱                         │
│          │   ╱                      ╲ │ ╱                          │
│          │  ╱ θ                      ╲│╱   ← 기기가 θ만큼 기울어짐   │
│          ├─────────▶ X (Global)       └─────▶ X (Body)             │
│                                                                    │
│   변환 공식 (회전 행렬):                                             │
│   ─────────────────────                                            │
│                                                                    │
│   ┌             ┐   ┌                   ┐   ┌      ┐              │
│   │ ax_global   │   │  cos(θ)   -sin(θ) │   │ ax   │              │
│   │             │ = │                   │ × │      │              │
│   │ ay_global   │   │  sin(θ)    cos(θ) │   │ ay   │              │
│   └             ┘   └                   ┘   └      ┘              │
│                                                                    │
│   풀어쓰면:                                                         │
│   ax_global = ax·cos(θ) - ay·sin(θ)                                │
│   ay_global = ax·sin(θ) + ay·cos(θ)                                │
│                                                                    │
└────────────────────────────────────────────────────────────────────┘
```

### 🧮 야코비안 행렬 (Jacobian Matrix) - 왜 필요한가?

**확장 칼만 필터(EKF)**는 비선형 시스템을 다룹니다.
야코비안은 **비선형 함수를 선형 근사**하는 도구입니다.

```
┌────────────────────────────────────────────────────────────────────┐
│  📐 야코비안 행렬 F = ∂f/∂x (상태 전이 함수의 편미분)                   │
├────────────────────────────────────────────────────────────────────┤
│                                                                    │
│       ┌                                                     ┐      │
│       │ ∂px/∂px  ∂px/∂py  ∂px/∂vx  ∂px/∂vy  ∂px/∂θ         │      │
│       │ ∂py/∂px  ∂py/∂py  ∂py/∂vx  ∂py/∂vy  ∂py/∂θ         │      │
│   F = │ ∂vx/∂px  ∂vx/∂py  ∂vx/∂vx  ∂vx/∂vy  ∂vx/∂θ         │      │
│       │ ∂vy/∂px  ∂vy/∂py  ∂vy/∂vx  ∂vy/∂vy  ∂vy/∂θ         │      │
│       │ ∂θ/∂px   ∂θ/∂py   ∂θ/∂vx   ∂θ/∂vy   ∂θ/∂θ          │      │
│       └                                                     ┘      │
│                                                                    │
│   계산 결과:                                                        │
│   ─────────                                                        │
│       ┌                                                          ┐ │
│       │  1    0    Δt   0    (-ax·sin(θ) - ay·cos(θ))·½·Δt²     │ │
│       │  0    1    0    Δt   ( ax·cos(θ) - ay·sin(θ))·½·Δt²     │ │
│   F = │  0    0    1    0    (-ax·sin(θ) - ay·cos(θ))·Δt        │ │
│       │  0    0    0    1    ( ax·cos(θ) - ay·sin(θ))·Δt        │ │
│       │  0    0    0    0    1                                   │ │
│       └                                                          ┘ │
│                                                                    │
│   대부분의 항이 0 또는 1이라 계산이 간단!                             │
│                                                                    │
└────────────────────────────────────────────────────────────────────┘
```

### 📝 Step 2: 보정 단계 수학 공식

**칼만 이득(Kalman Gain)** K를 계산하고, 측정값으로 예측을 보정합니다.

```
┌────────────────────────────────────────────────────────────────────┐
│  📐 보정 방정식 (Update Equations)                                   │
├────────────────────────────────────────────────────────────────────┤
│                                                                    │
│  1. 잔차 계산 (Residual = 측정값 - 예측값)                           │
│  ────────────────────────────────────────                          │
│     y = z - H·x̂_{k|k-1}                                            │
│                                                                    │
│     여기서:                                                         │
│     z = [gps_x, gps_y]  ← GPS 측정값                               │
│     H = [1 0 0 0 0]     ← 측정 행렬 (위치만 측정 가능)               │
│         [0 1 0 0 0]                                                │
│                                                                    │
│  2. 칼만 이득 계산 (★ 핵심!)                                         │
│  ─────────────────────────                                         │
│     S = H·P·Hᵀ + R       ← 잔차 공분산                              │
│     K = P·Hᵀ·S⁻¹          ← 칼만 이득                               │
│                                                                    │
│     📌 K가 크면 → 측정값(GPS)을 더 신뢰                              │
│     📌 K가 작으면 → 예측값(센서)을 더 신뢰                            │
│                                                                    │
│  3. 상태 보정                                                       │
│  ─────────────                                                     │
│     x̂_k = x̂_{k|k-1} + K·y                                          │
│                                                                    │
│  4. 공분산 보정                                                     │
│  ─────────────                                                     │
│     P_k = (I - K·H)·P_{k|k-1}                                      │
│                                                                    │
└────────────────────────────────────────────────────────────────────┘
```

### 🎚️ Q와 R 파라미터 (노이즈 공분산)

**Q (프로세스 노이즈):** 모델의 불확실성
**R (측정 노이즈):** 센서의 불확실성 (GPS 오차)

```
┌────────────────────────────────────────────────────────────────────┐
│  🎚️ 파라미터 설정 가이드                                            │
├────────────────────────────────────────────────────────────────────┤
│                                                                    │
│   Q 행렬 (프로세스 노이즈):                                          │
│   ┌                                   ┐                            │
│   │ 0.01   0     0     0     0       │  ← 위치 불확실성 작음        │
│   │  0    0.01   0     0     0       │                             │
│   │  0     0    0.1    0     0       │  ← 속도 불확실성 조금 큼     │
│   │  0     0     0    0.1    0       │                             │
│   │  0     0     0     0    0.01     │  ← 방향 불확실성 작음        │
│   └                                   ┘                            │
│                                                                    │
│   R 행렬 (GPS 측정 노이즈):                                          │
│   ┌           ┐                                                    │
│   │ 5.0   0   │  ← GPS X 오차 약 5m                                │
│   │  0   5.0  │  ← GPS Y 오차 약 5m                                │
│   └           ┘                                                    │
│                                                                    │
│   💡 조정 팁:                                                       │
│   • GPS 신호 좋을 때 (HDOP < 2): R을 작게 → GPS 더 신뢰             │
│   • 건물 사이에서 (HDOP > 5): R을 크게 → 센서 더 신뢰               │
│   • 빠르게 뛸 때: Q_velocity를 크게 → 급격한 변화 허용              │
│                                                                    │
└────────────────────────────────────────────────────────────────────┘
```

### 🧮 구체적 계산 예시 (손으로 따라해보기)

```
┌────────────────────────────────────────────────────────────────────┐
│  📊 예시: 한 스텝 칼만 필터 계산                                      │
├────────────────────────────────────────────────────────────────────┤
│                                                                    │
│  🔹 초기 상태: x = [0, 0, 1.5, 0.5, 0]                              │
│     (위치 0,0 / 속도 1.5, 0.5 m/s / 방향 0°)                        │
│                                                                    │
│  🔹 입력값: ax=-0.0497, ay=0.1197, ωz=0.0999                        │
│  🔹 Δt = 0.01초                                                    │
│                                                                    │
│  📌 예측 단계:                                                      │
│  ─────────────                                                     │
│  θ = 0 이므로 cos(0)=1, sin(0)=0                                   │
│  ax_global = -0.0497×1 - 0.1197×0 = -0.0497                        │
│  ay_global = -0.0497×0 + 0.1197×1 =  0.1197                        │
│                                                                    │
│  px = 0 + 1.5×0.01 + 0.5×(-0.0497)×0.01² = 0.0150 m               │
│  py = 0 + 0.5×0.01 + 0.5×(0.1197)×0.01²  = 0.0050 m               │
│  vx = 1.5 + (-0.0497)×0.01 = 1.4995 m/s                           │
│  vy = 0.5 + (0.1197)×0.01  = 0.5012 m/s                           │
│  θ  = 0 + 0.0999×0.01 = 0.000999 rad                              │
│                                                                    │
│  🔹 예측 결과: x̂ = [0.015, 0.005, 1.4995, 0.5012, 0.001]           │
│                                                                    │
│  📌 보정 단계:                                                      │
│  ─────────────                                                     │
│  GPS 측정값: z = [0.018, 0.003] (약간 다름)                         │
│  잔차: y = [0.018-0.015, 0.003-0.005] = [0.003, -0.002]            │
│                                                                    │
│  칼만 이득 K ≈ [[0.02], [0.02], ...]                               │
│  보정: x = x̂ + K×y                                                 │
│       px = 0.015 + 0.02×0.003 = 0.01506 m                         │
│       py = 0.005 + 0.02×(-0.002) = 0.00496 m                      │
│                                                                    │
│  🔹 최종 결과: GPS보다 예측을 더 신뢰 (K가 작음)                      │
│                                                                    │
└────────────────────────────────────────────────────────────────────┘
```

---

### 💻 칼만 필터 코드 (Python - 시뮬레이션용)

```python
# kalman_filter.py - 확장 칼만 필터 (EKF) 구현

import numpy as np

class ExtendedKalmanFilter:
    """
    2D 위치/속도/방향 추정을 위한 확장 칼만 필터
  
    상태 벡터: [px, py, vx, vy, theta]
    - px, py: 위치 (m)
    - vx, vy: 속도 (m/s)
    - theta: 방향 (rad)
    """
  
    def __init__(self, dt=0.01):
        self.dt = dt  # 샘플링 간격 (100Hz = 0.01초)
    
        # 상태 벡터 초기화 [px, py, vx, vy, theta]
        self.x = np.array([0.0, 0.0, 1.5, 0.5, 0.0])
    
        # 오차 공분산 행렬 초기화
        self.P = np.eye(5) * 0.1
    
        # 프로세스 노이즈 (시스템 불확실성)
        self.Q = np.diag([0.01, 0.01, 0.1, 0.1, 0.01])
    
        # 측정 노이즈 (GPS 불확실성)
        self.R = np.diag([5.0, 5.0])  # GPS 오차 약 5m
  
    def predict(self, ax, ay, omega_z):
        """
        예측 단계 (Prediction Step)
    
        센서 입력:
        - ax, ay: 가속도 (m/s²)
        - omega_z: 각속도 (rad/s)
        """
        dt = self.dt
        px, py, vx, vy, theta = self.x
    
        # 좌표 회전 (Body → Global)
        cos_t = np.cos(theta)
        sin_t = np.sin(theta)
        ax_global = ax * cos_t - ay * sin_t
        ay_global = ax * sin_t + ay * cos_t
    
        # 상태 전이 (등가속도 운동 공식)
        px_new = px + vx * dt + 0.5 * ax_global * dt**2
        py_new = py + vy * dt + 0.5 * ay_global * dt**2
        vx_new = vx + ax_global * dt
        vy_new = vy + ay_global * dt
        theta_new = theta + omega_z * dt
    
        self.x = np.array([px_new, py_new, vx_new, vy_new, theta_new])
    
        # 야코비안 행렬 계산 (선형화)
        F = self._compute_jacobian(ax, ay, theta)
    
        # 오차 공분산 예측
        self.P = F @ self.P @ F.T + self.Q
    
        return self.x.copy()
  
    def update(self, gps_x, gps_y):
        """
        보정 단계 (Update Step)
    
        GPS 측정값으로 예측값 보정
        """
        # 측정 행렬 (위치만 측정 가능)
        H = np.array([
            [1, 0, 0, 0, 0],
            [0, 1, 0, 0, 0]
        ])
    
        # 측정값
        z = np.array([gps_x, gps_y])
    
        # 예측된 측정값
        z_pred = H @ self.x
    
        # 잔차 (측정값 - 예측값)
        y = z - z_pred
    
        # 칼만 이득 계산
        S = H @ self.P @ H.T + self.R
        K = self.P @ H.T @ np.linalg.inv(S)
    
        # 상태 보정
        self.x = self.x + K @ y
    
        # 오차 공분산 보정
        I = np.eye(5)
        self.P = (I - K @ H) @ self.P
    
        return self.x.copy()
  
    def _compute_jacobian(self, ax, ay, theta):
        """상태 전이 함수의 야코비안 (선형화)"""
        dt = self.dt
        cos_t = np.cos(theta)
        sin_t = np.sin(theta)
    
        F = np.eye(5)
        F[0, 2] = dt  # dpx/dvx
        F[1, 3] = dt  # dpy/dvy
    
        # dpx/dtheta, dpy/dtheta (비선형 항)
        F[0, 4] = (-ax * sin_t - ay * cos_t) * 0.5 * dt**2
        F[1, 4] = (ax * cos_t - ay * sin_t) * 0.5 * dt**2
    
        return F


# ========== 사용 예시 ==========
if __name__ == "__main__":
    ekf = ExtendedKalmanFilter(dt=0.01)
  
    # 센서 입력값 (Step 2에서 변환된 값)
    ax = -0.0497    # m/s²
    ay = 0.1197     # m/s²
    omega_z = 0.0999  # rad/s
  
    # 예측 단계
    predicted = ekf.predict(ax, ay, omega_z)
  
    print("=== 예측 결과 ===")
    print(f"위치: ({predicted[0]:.6f}, {predicted[1]:.6f}) m")
    print(f"속도: ({predicted[2]:.6f}, {predicted[3]:.6f}) m/s")
    print(f"방향: {predicted[4]:.6f} rad ({np.degrees(predicted[4]):.3f}°)")
```

### 💻 칼만 필터 코드 (C언어 - ESP32 임베디드용)

```c
// ekf.c - 임베디드용 확장 칼만 필터

#include <math.h>
#include <string.h>

#define STATE_SIZE 5

typedef struct {
    float x[STATE_SIZE];        // 상태 벡터 [px, py, vx, vy, theta]
    float P[STATE_SIZE][STATE_SIZE];  // 오차 공분산 행렬
    float dt;                   // 샘플링 간격
} EKF;

// 초기화
void ekf_init(EKF* ekf, float dt) {
    ekf->dt = dt;
  
    // 상태 초기화
    memset(ekf->x, 0, sizeof(ekf->x));
    ekf->x[2] = 1.5f;  // 초기 vx
    ekf->x[3] = 0.5f;  // 초기 vy
  
    // P 행렬 초기화 (단위 행렬 × 0.1)
    memset(ekf->P, 0, sizeof(ekf->P));
    for (int i = 0; i < STATE_SIZE; i++) {
        ekf->P[i][i] = 0.1f;
    }
}

// 예측 단계
void ekf_predict(EKF* ekf, float ax, float ay, float omega_z) {
    float dt = ekf->dt;
    float px = ekf->x[0];
    float py = ekf->x[1];
    float vx = ekf->x[2];
    float vy = ekf->x[3];
    float theta = ekf->x[4];
  
    // 좌표 회전
    float cos_t = cosf(theta);
    float sin_t = sinf(theta);
    float ax_global = ax * cos_t - ay * sin_t;
    float ay_global = ax * sin_t + ay * cos_t;
  
    // 상태 업데이트 (등가속도 운동)
    ekf->x[0] = px + vx * dt + 0.5f * ax_global * dt * dt;
    ekf->x[1] = py + vy * dt + 0.5f * ay_global * dt * dt;
    ekf->x[2] = vx + ax_global * dt;
    ekf->x[3] = vy + ay_global * dt;
    ekf->x[4] = theta + omega_z * dt;
}

// 사용 예시
void ekf_example() {
    EKF ekf;
    ekf_init(&ekf, 0.01f);  // 100Hz
  
    // 센서값 (물리 단위로 변환된 값)
    float ax = -0.0497f;
    float ay = 0.1197f;
    float omega_z = 0.0999f;
  
    // 예측
    ekf_predict(&ekf, ax, ay, omega_z);
  
    printf("위치: (%.6f, %.6f) m\n", ekf.x[0], ekf.x[1]);
    printf("속도: (%.6f, %.6f) m/s\n", ekf.x[2], ekf.x[3]);
    printf("방향: %.6f rad\n", ekf.x[4]);
}
```

### ✅ Step 3 결과: 예측된 상태

| 변수 | 이전 값 | 예측된 값            | 변화량  | 해석          |
| ---- | ------- | -------------------- | ------- | ------------- |
| px   | 0 m     | **0.015 m**    | +1.5 cm | 앞으로 이동   |
| py   | 0 m     | **0.005 m**    | +0.5 cm | 옆으로 이동   |
| vx   | 1.5 m/s | **1.4995 m/s** | -0.0005 | 살짝 감속     |
| vy   | 0.5 m/s | **0.5012 m/s** | +0.0012 | 살짝 가속     |
| θ   | 0 rad   | **0.001 rad**  | +0.06° | 왼쪽으로 회전 |

---

## 7.2 ❤️ 심박 센서 데이터 처리 (PPG → BPM)

### 🤔 심박 센서는 어떻게 작동하나요?

**PPG (Photoplethysmography)** = 광혈류 측정법

```
┌────────────────────────────────────────────────────────────────────┐
│  ❤️ PPG 센서 원리                                                   │
├────────────────────────────────────────────────────────────────────┤
│                                                                    │
│     LED 빛 ──────────▶ 피부                                        │
│                        │                                           │
│                        ▼                                           │
│                    [혈관 🩸]                                        │
│                        │                                           │
│       반사된 빛 ◀──────┘                                           │
│           │                                                        │
│           ▼                                                        │
│      [광 센서]                                                      │
│                                                                    │
│   💡 혈액이 많으면 → 빛 흡수 ↑ → 센서 값 ↓                           │
│   💡 심장 수축 시 → 혈액 많음 → 피크(peak) 발생!                      │
│                                                                    │
│   시간 그래프:                                                       │
│                                                                    │
│   센서값 ▲                                                          │
│         │    ∧      ∧      ∧      ∧                               │
│         │   / \    / \    / \    / \                              │
│         │  /   \  /   \  /   \  /   \                             │
│         │ /     \/     \/     \/     \                            │
│         └──┼──────┼──────┼──────┼────────▶ 시간                    │
│            │      │      │      │                                  │
│            └──────┘      └──────┘                                  │
│              RR 간격       RR 간격                                   │
│              (= 1/심박수)                                           │
│                                                                    │
│   BPM = 60 ÷ RR간격(초)                                             │
│   예: RR = 0.5초 → BPM = 60 ÷ 0.5 = 120 BPM                        │
│                                                                    │
└────────────────────────────────────────────────────────────────────┘
```

### 💻 PPG → BPM 변환 코드 (C언어)

```c
// ppg_processing.c - PPG 신호에서 심박수 추출

#include <stdint.h>
#include <stdbool.h>

#define SAMPLE_RATE     100       // 100Hz 샘플링
#define BUFFER_SIZE     400       // 4초 버퍼 (4 × 100)
#define MIN_BPM         40        // 최소 심박수
#define MAX_BPM         200       // 최대 심박수

typedef struct {
    uint32_t ir_buffer[BUFFER_SIZE];   // IR LED 값 버퍼
    int buffer_index;                   // 현재 인덱스
    
    // 피크 검출용
    uint32_t last_peak_value;
    int last_peak_index;
    int peak_count;
    
    // 결과
    int bpm;                           // 계산된 심박수
    float rr_interval;                  // RR 간격 (초)
} PPGProcessor;

// 초기화
void ppg_init(PPGProcessor* ppg) {
    ppg->buffer_index = 0;
    ppg->last_peak_value = 0;
    ppg->last_peak_index = 0;
    ppg->peak_count = 0;
    ppg->bpm = 0;
    ppg->rr_interval = 0;
}

// 이동 평균 필터 (노이즈 제거)
uint32_t moving_average(uint32_t* buffer, int index, int window_size) {
    uint32_t sum = 0;
    int count = 0;
    
    for (int i = -window_size/2; i <= window_size/2; i++) {
        int idx = index + i;
        if (idx >= 0 && idx < BUFFER_SIZE) {
            sum += buffer[idx];
            count++;
        }
    }
    
    return sum / count;
}

// 피크 검출 알고리즘
bool detect_peak(PPGProcessor* ppg, uint32_t current_value, int current_index) {
    // 5샘플 이동 평균으로 스무딩
    uint32_t smoothed = moving_average(ppg->ir_buffer, current_index, 5);
    
    // 이전 값들과 비교 (로컬 최대값 찾기)
    if (current_index < 2) return false;
    
    uint32_t prev1 = ppg->ir_buffer[current_index - 1];
    uint32_t prev2 = ppg->ir_buffer[current_index - 2];
    
    // 현재가 이전보다 작아지기 시작하면 → 피크 직전!
    if (prev1 > prev2 && prev1 > current_value) {
        // 피크 간 최소 간격 체크 (40 BPM = 1.5초 = 150샘플)
        int min_interval = 60 * SAMPLE_RATE / MAX_BPM;  // 30샘플 (200 BPM)
        
        if (current_index - ppg->last_peak_index > min_interval) {
            return true;
        }
    }
    
    return false;
}

// 새 샘플 처리
void ppg_process_sample(PPGProcessor* ppg, uint32_t ir_value) {
    // 버퍼에 저장
    ppg->ir_buffer[ppg->buffer_index] = ir_value;
    
    // 피크 검출
    if (detect_peak(ppg, ir_value, ppg->buffer_index)) {
        // RR 간격 계산
        int samples_since_last = ppg->buffer_index - ppg->last_peak_index;
        ppg->rr_interval = (float)samples_since_last / SAMPLE_RATE;
        
        // BPM 계산
        if (ppg->rr_interval > 0) {
            int calculated_bpm = (int)(60.0f / ppg->rr_interval);
            
            // 유효 범위 체크
            if (calculated_bpm >= MIN_BPM && calculated_bpm <= MAX_BPM) {
                ppg->bpm = calculated_bpm;
            }
        }
        
        ppg->last_peak_index = ppg->buffer_index;
        ppg->peak_count++;
    }
    
    // 인덱스 순환
    ppg->buffer_index = (ppg->buffer_index + 1) % BUFFER_SIZE;
}

// 사용 예시
void ppg_example() {
    PPGProcessor ppg;
    ppg_init(&ppg);
    
    // 시뮬레이션: IR 센서 값 (실제로는 I2C로 읽음)
    uint32_t sample_data[] = {
        50213, 50198, 50245, 50312, 50456,  // 상승
        50589, 50634, 50612, 50523, 50398,  // 피크 후 하강
        50234, 50156, 50089, 50045, 50023,  // 하강
        50012, 50034, 50078, 50145, 50234   // 상승 시작
        // ... 계속
    };
    
    for (int i = 0; i < 200; i++) {  // 2초간의 데이터
        ppg_process_sample(&ppg, sample_data[i % 20]);
    }
    
    printf("현재 심박수: %d BPM\n", ppg.bpm);
    printf("RR 간격: %.3f 초\n", ppg.rr_interval);
}
```

### 📊 PPG 처리 과정 요약

```
┌────────────────────────────────────────────────────────────────────┐
│  📊 PPG → BPM 처리 단계                                             │
├────────────────────────────────────────────────────────────────────┤
│                                                                    │
│  1️⃣ Raw 데이터 수집 (100Hz)                                        │
│     IR: [50213, 50198, 50245, 50312, 50456, ...]                  │
│                         │                                          │
│                         ▼                                          │
│  2️⃣ 노이즈 필터링 (이동 평균)                                        │
│     smoothed: [50212, 50219, 50252, 50338, ...]                   │
│                         │                                          │
│                         ▼                                          │
│  3️⃣ 피크 검출                                                       │
│     peaks: [index: 47, 97, 147, ...]                              │
│                         │                                          │
│                         ▼                                          │
│  4️⃣ RR 간격 계산                                                    │
│     intervals: [50샘플, 50샘플, ...] = 0.5초                        │
│                         │                                          │
│                         ▼                                          │
│  5️⃣ BPM 계산                                                        │
│     BPM = 60 ÷ 0.5 = 120 BPM ❤️                                    │
│                         │                                          │
│                         ▼                                          │
│  6️⃣ 심박 존(Zone) 판정 → 게임 점수 배율!                             │
│                                                                    │
└────────────────────────────────────────────────────────────────────┘
```

---

## 8. Step 4: 게이미피케이션 로직

### 🗺️ 영역 정복 (땅따먹기)

**규칙:**

1. 사용자가 달리면서 경로를 그립니다
2. 경로가 닫힌 다각형을 만들면...
3. 그 영역을 "정복"한 것으로 인정! 🏆

```
        시작 →  ─────────┐
                        │
                        │          이 영역을
                        │          정복!  ⭐
                        │
        끝   ← ─────────┘
```

### 💻 Point-in-Polygon 알고리즘 (Python)

```python
# territory.py - 영역 정복 판정 알고리즘

from typing import List, Tuple
import numpy as np

Point = Tuple[float, float]

def is_polygon_closed(path: List[Point], threshold: float = 10.0) -> bool:
    """
    경로가 닫힌 다각형인지 확인
  
    Args:
        path: GPS 좌표 리스트 [(x1,y1), (x2,y2), ...]
        threshold: 시작점과 끝점 사이 거리 허용치 (미터)
    """
    if len(path) < 4:  # 최소 삼각형 + 시작점
        return False
  
    start = np.array(path[0])
    end = np.array(path[-1])
    distance = np.linalg.norm(end - start)
  
    return distance < threshold


def calculate_polygon_area(vertices: List[Point]) -> float:
    """
    다각형 면적 계산 (Shoelace 공식)
  
    Args:
        vertices: 다각형 꼭짓점 좌표
  
    Returns:
        면적 (제곱미터)
    """
    n = len(vertices)
    if n < 3:
        return 0.0
  
    area = 0.0
    for i in range(n):
        j = (i + 1) % n
        area += vertices[i][0] * vertices[j][1]
        area -= vertices[j][0] * vertices[i][1]
  
    return abs(area) / 2.0


def point_in_polygon(point: Point, polygon: List[Point]) -> bool:
    """
    점이 다각형 내부에 있는지 판정 (Ray Casting 알고리즘)
  
    Args:
        point: 판정할 점 (x, y)
        polygon: 다각형 꼭짓점들
  
    Returns:
        True면 내부, False면 외부
    """
    x, y = point
    n = len(polygon)
    inside = False
  
    j = n - 1
    for i in range(n):
        xi, yi = polygon[i]
        xj, yj = polygon[j]
    
        if ((yi > y) != (yj > y)) and \
           (x < (xj - xi) * (y - yi) / (yj - yi) + xi):
            inside = not inside
    
        j = i
  
    return inside


# ========== 사용 예시 ==========
if __name__ == "__main__":
    # 사용자가 달린 경로 (GPS 좌표, 미터 단위로 변환됨)
    running_path = [
        (0, 0),      # 시작
        (100, 0),    # 동쪽으로 100m
        (100, 50),   # 북쪽으로 50m
        (0, 50),     # 서쪽으로 100m
        (0, 0)       # 시작점으로 돌아옴
    ]
  
    # 닫힌 다각형인지 확인
    if is_polygon_closed(running_path):
        print("✅ 영역 완성!")
    
        # 면적 계산
        area = calculate_polygon_area(running_path)
        print(f"📐 정복한 면적: {area:.1f} m² ({area/10000:.3f} 헥타르)")
    
        # 점수 계산 (1m² = 1점)
        score = int(area)
        print(f"🏆 획득 점수: {score} 점")
    else:
        print("❌ 경로가 닫히지 않음")
```

### 💪 심박수 기반 점수 시스템 (Python)

```python
# scoring.py - 심박수 기반 동적 점수 계산

from enum import Enum
from dataclasses import dataclass

class HeartRateZone(Enum):
    """심박수 존 (운동 강도)"""
    ZONE_1 = 1  # 50-60% HRmax (매우 가벼움)
    ZONE_2 = 2  # 60-70% HRmax (가벼움)
    ZONE_3 = 3  # 70-80% HRmax (보통)
    ZONE_4 = 4  # 80-90% HRmax (고강도)
    ZONE_5 = 5  # 90-100% HRmax (최대)

@dataclass
class UserProfile:
    """사용자 프로필"""
    age: int
    resting_hr: int = 60
  
    @property
    def max_hr(self) -> int:
        """최대 심박수 (220 - 나이)"""
        return 220 - self.age

def get_hr_zone(bpm: int, user: UserProfile) -> HeartRateZone:
    """현재 심박수로 운동 존 판정"""
    hr_reserve = user.max_hr - user.resting_hr
    intensity = (bpm - user.resting_hr) / hr_reserve
  
    if intensity < 0.5:
        return HeartRateZone.ZONE_1
    elif intensity < 0.6:
        return HeartRateZone.ZONE_2
    elif intensity < 0.7:
        return HeartRateZone.ZONE_3
    elif intensity < 0.8:
        return HeartRateZone.ZONE_4
    else:
        return HeartRateZone.ZONE_5

def calculate_score(base_score: float, zone: HeartRateZone) -> float:
    """심박수 존에 따른 점수 배율 적용"""
    multipliers = {
        HeartRateZone.ZONE_1: 0.8,
        HeartRateZone.ZONE_2: 1.0,
        HeartRateZone.ZONE_3: 1.5,
        HeartRateZone.ZONE_4: 2.0,
        HeartRateZone.ZONE_5: 2.5,
    }
    return base_score * multipliers[zone]


# ========== 사용 예시 ==========
if __name__ == "__main__":
    user = UserProfile(age=25)
    print(f"최대 심박수: {user.max_hr} bpm")
  
    # 시뮬레이션: 다양한 심박수에서의 점수
    base_area_score = 5000  # 5000m² 영역 정복
  
    for bpm in [100, 130, 150, 170]:
        zone = get_hr_zone(bpm, user)
        final_score = calculate_score(base_area_score, zone)
        print(f"심박수 {bpm}bpm (Zone {zone.value}): {final_score:.0f}점")
```

---

## 9. 데이터 파이프라인

### 📊 Kafka 토픽 설계

| Topic              | 데이터                          | 빈도               | 보관 |
| ------------------ | ------------------------------- | ------------------ | ---- |
| `raw.gps.events` | 위도, 경도, 정확도, 시간        | ~1회/초            | 7일  |
| `raw.hr.events`  | 심박수, RR 간격                 | ~1회/초            | 7일  |
| `raw.imu.events` | 가속도[3], 자이로[3], 지자기[3] | **~50회/초** | 3일  |

### 💻 FastAPI 백엔드 서버 (Python)

```python
# main.py - FastAPI 서버

from fastapi import FastAPI, WebSocket
from pydantic import BaseModel
from typing import List
from datetime import datetime
import asyncio

app = FastAPI(title="헬스케어 게이미피케이션 API")

# 데이터 모델
class GPSData(BaseModel):
    user_id: str
    latitude: float
    longitude: float
    accuracy: float
    timestamp: datetime

class IMUData(BaseModel):
    user_id: str
    accel: List[float]   # [x, y, z]
    gyro: List[float]    # [x, y, z]
    timestamp: datetime

class HeartRateData(BaseModel):
    user_id: str
    bpm: int
    rr_interval: float
    timestamp: datetime

# 웹소켓으로 실시간 위치 스트리밍
@app.websocket("/ws/location/{user_id}")
async def location_websocket(websocket: WebSocket, user_id: str):
    await websocket.accept()
  
    while True:
        # 클라이언트로부터 센서 데이터 수신
        data = await websocket.receive_json()
    
        # 칼만 필터 적용 (실제로는 EKF 클래스 사용)
        filtered_position = {
            "x": data["gps_x"] * 0.8 + data["imu_x"] * 0.2,
            "y": data["gps_y"] * 0.8 + data["imu_y"] * 0.2,
        }
    
        # 보정된 위치 전송
        await websocket.send_json(filtered_position)

# REST API 엔드포인트
@app.post("/api/v1/gps")
async def receive_gps(data: GPSData):
    # Kafka로 전송 (실제 구현 시)
    # await kafka_producer.send("raw.gps.events", data.dict())
    return {"status": "received", "user_id": data.user_id}

@app.post("/api/v1/territory/validate")
async def validate_territory(path: List[List[float]]):
    """경로가 유효한 영역인지 검증"""
    from territory import is_polygon_closed, calculate_polygon_area
  
    points = [(p[0], p[1]) for p in path]
  
    if not is_polygon_closed(points):
        return {"valid": False, "message": "경로가 닫히지 않음"}
  
    area = calculate_polygon_area(points)
    return {
        "valid": True,
        "area_m2": area,
        "score": int(area)
    }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

---

## 10. 프로젝트 로드맵

### Phase 1: 하드웨어 ✅ (현재)

- [X] ESP32-S3 + 센서들 납땜
- [X] I2C/UART 통신 구현
- [X] Raw Data SD카드 저장
- [X] Python으로 칼만 필터 시뮬레이션

### Phase 2: 연결성 🔄 (진행 중)

- [ ] BLE 5.0으로 앱과 통신
- [ ] iOS/Android 앱 지도 연동
- [ ] 실시간 영역 정복 시각화

### Phase 3: 백엔드 📋 (예정)

- [ ] Kafka & 시계열 DB 구축
- [ ] 심박변이도(HRV) 분석
- [ ] 리더보드 시스템
