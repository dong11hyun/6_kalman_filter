# MPU-9250 센서 데이터 기반 확장 칼만 필터(EKF) 완전 가이드

이 문서는 MPU-9250 IMU 센서에서 데이터를 읽어 확장 칼만 필터(Extended Kalman Filter)로 위치/속도/방향을 추정하는 **전체 과정**을 처음부터 끝까지 상세히 설명합니다.

---

## 📑 목차

1. [시스템 전체 구조](#1-시스템-전체-구조)
2. [Step 1: I2C 레지스터에서 Raw Data 읽기](#2-step-1-i2c-레지스터에서-raw-data-읽기)
3. [Step 2: Raw Data를 물리 단위(SI)로 변환](#3-step-2-raw-data를-물리-단위si로-변환)
4. [Step 3: EKF 예측 단계 계산](#4-step-3-ekf-예측-단계-계산)
5. [최종 결과 정리](#5-최종-결과-정리)
6. [임베디드 최적화 팁](#6-임베디드-최적화-팁)

---

## 1. 시스템 전체 구조

### 🔍 이 프로젝트는 무엇을 하나요?

스마트폰이나 웨어러블 기기에 들어있는 **가속도 센서**와 **자이로 센서**의 데이터를 읽어서, 사용자가 **어디에 있는지(위치)**, **얼마나 빠르게 움직이는지(속도)**, **어느 방향을 보고 있는지(방향)**를 계산합니다.

### 📊 데이터 흐름 한눈에 보기

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          전체 데이터 처리 흐름                               │
└─────────────────────────────────────────────────────────────────────────────┘

   [MPU-9250 센서]
        │
        ▼
┌───────────────────┐     I2C 통신으로 레지스터 읽기
│ Step 1: Raw Data  │     예: ACCEL_X = 0xFF, 0xAD (16진수)
│   (16비트 정수)    │         → -83 (10진수)
└─────────┬─────────┘
          │
          ▼
┌───────────────────┐     Sensitivity Scale Factor 적용
│ Step 2: 물리 단위 │     예: -83 ÷ 16384 × 9.8 = -0.0497 m/s²
│   (m/s², rad/s)   │
└─────────┬─────────┘
          │
          ▼
┌───────────────────┐     등가속도 운동 공식 적용
│ Step 3: EKF 예측  │     p = p + v×dt + ½a×dt²
│  (위치/속도/방향)  │     v = v + a×dt
└─────────┬─────────┘     θ = θ + ω×dt
          │
          ▼
   [상태 벡터 출력]
   [px, py, vx, vy, θ]
```

### 🎯 예제 시나리오

**상황:** 사용자가 약간 앞으로 뛰면서(+X 속도 유지), 몸이 살짝 흔들리고(-X, +Y 가속), 아주 미세하게 왼쪽으로 회전하려는 순간

이 상황에서 센서가 측정한 값들을 따라가며 전체 과정을 이해해봅시다.

---

## 2. Step 1: I2C 레지스터에서 Raw Data 읽기

### 🤔 왜 이 과정이 필요한가요?

MPU-9250 센서는 측정값을 디지털 숫자로 저장합니다. 하지만 이 숫자는 우리가 아는 "미터"나 "각도" 같은 단위가 아닙니다. 
**센서 내부의 메모리(레지스터)**에 저장된 **2진수 Raw 데이터**를 먼저 읽어와야 합니다.

### 📌 MPU-9250 센서 설정

| 설정 항목 | 값 | 의미 |
|-----------|-----|------|
| 가속도 측정 범위 | ±2g | 최대 ±2×중력가속도까지 측정 가능 |
| 자이로 측정 범위 | ±250°/s | 최대 ±초당 250도 회전까지 측정 가능 |
| 데이터 형식 | 16비트 정수(int16) | -32,768 ~ +32,767 범위 |

### 📡 I2C 레지스터 구조

MPU-9250은 데이터를 **상위 8비트(High Byte)**와 **하위 8비트(Low Byte)**로 나누어 저장합니다. (Big-endian 방식)

```plaintext
[I2C Read Sequence from Address 0x3B]

Addr  | Name         | Hex Value | Binary View (8-bit)  | 설명
------+--------------+-----------+----------------------+------------------
0x3B  | ACCEL_X_H    | 0xFF      | 1111 1111            | -83의 상위 비트
0x3C  | ACCEL_X_L    | 0xAD      | 1010 1101            | -83의 하위 비트
0x3D  | ACCEL_Y_H    | 0x00      | 0000 0000            | 200의 상위 비트
0x3E  | ACCEL_Y_L    | 0xC8      | 1100 1000            | 200의 하위 비트
0x3F  | ACCEL_Z_H    | 0x40      | 0100 0000            | 16500의 상위 비트
0x40  | ACCEL_Z_L    | 0x74      | 0111 0100            | 16500의 하위 비트
...   | ...          | ...       | ...                  | ...
0x47  | GYRO_Z_H     | 0x02      | 0000 0010            | 750의 상위 비트
0x48  | GYRO_Z_L     | 0xEE      | 1110 1110            | 750의 하위 비트
```

### 🔢 Hex → Int16 변환 상세 설명

#### (1) ACCEL_X (결과: -83)

**음수 표현: 2의 보수(Two's Complement)**

컴퓨터는 음수를 "2의 보수"라는 방식으로 표현합니다.

```
읽어온 Hex 값: 0xFF, 0xAD

1. 바이트 결합:
   High Byte (0xFF) = 1111 1111
   Low Byte  (0xAD) = 1010 1101
   
   결합: 1111 1111 1010 1101 (16비트)

2. 2의 보수 해석:
   - 최상위 비트(MSB)가 1 → 음수!
   - 2의 보수 변환: 비트 반전 후 +1
   - 0000 0000 0101 0010 + 1 = 0000 0000 0101 0011 = 83
   - 결과: -83
```

#### (2) ACCEL_Y (결과: 200)

**양수는 간단히 16진수 → 10진수 변환**

```
읽어온 Hex 값: 0x00, 0xC8

1. 바이트 결합:
   High Byte (0x00) = 0000 0000
   Low Byte  (0xC8) = 1100 1000
   
   결합: 0000 0000 1100 1000

2. 10진수 변환:
   - 최상위 비트(MSB)가 0 → 양수!
   - 직접 계산: 128 + 64 + 8 = 200
```

#### (3) ACCEL_Z (결과: 16500, 약 1g)

```
읽어온 Hex 값: 0x40, 0x74

검산: (0x40 × 256) + 0x74 = (64 × 256) + 116 = 16,384 + 116 = 16,500
```

> **💡 참고:** Z축 값이 약 16,384인 것은 센서가 중력(1g)을 감지하고 있기 때문입니다. 센서가 평평하게 놓여있으면 Z축이 지구 중력을 온전히 받습니다.

#### (4) GYRO_Z (결과: 750)

```
읽어온 Hex 값: 0x02, 0xEE

검산: (0x02 × 256) + 0xEE = (2 × 256) + 238 = 512 + 238 = 750
```

### ✅ Step 1 결과: Raw Data 값

| 센서 | 레지스터 | Raw 값 (Int16) | 의미 |
|------|----------|----------------|------|
| ACCEL_X | 0x3B-0x3C | **-83** | 미세한 X축 감속 |
| ACCEL_Y | 0x3D-0x3E | **200** | 우측으로 약간 쏠림 |
| ACCEL_Z | 0x3F-0x40 | **16500** | 중력가속도 (≈1g) |
| GYRO_Z | 0x47-0x48 | **750** | Z축 회전 (왼쪽으로) |

---

## 3. Step 2: Raw Data를 물리 단위(SI)로 변환

### 🤔 왜 이 과정이 필요한가요?

Raw Data "-83"이라는 숫자만 봐서는 "얼마나 빨리 가속하는지" 알 수 없습니다. 
이 숫자를 우리가 아는 **물리 단위(m/s², rad/s)**로 바꿔야 계산이 가능합니다.

### 📐 핵심 개념: Sensitivity Scale Factor

**Sensitivity(민감도)**란 "실제 물리량 1단위가 센서값 몇으로 표현되는가"를 뜻합니다.

| 센서 | 설정 | Sensitivity | 의미 |
|------|------|-------------|------|
| 가속도 | ±2g | 16,384 LSB/g | 1g = 16,384 |
| 자이로 | ±250°/s | 131 LSB/(°/s) | 1°/s = 131 |

> **LSB란?** Least Significant Bit. 센서가 출력하는 가장 작은 단위입니다.

---

### 🧮 가속도 변환 공식 (상세)

$$
a_{(m/s^2)} = \frac{\text{Raw Data}}{\text{Sensitivity}} \times g_{표준}
$$

여기서 $g_{표준} = 9.80665 \, m/s^2$ (표준 중력 가속도)

---

#### ▶ ACCEL_X 계산 분해

$$
a_x = \frac{-83}{16384} \times 9.80665 \approx \mathbf{-0.0497 \, m/s^2}
$$

**각 요소의 의미:**

| 기호 | 값 | 설명 |
|------|-----|------|
| -83 | `[Raw Data]` | 센서 레지스터에서 읽어온 16비트 정수 원본 값 |
| 16384 | `[Sensitivity]` | ±2g 모드에서 1g = 16,384 LSB |
| -0.00506 | `[중간값]` | g 단위로 변환된 값 (약 -0.005g) |
| 9.80665 | `[표준 중력]` | g → m/s² 변환 상수 |
| **-0.0497** | `[최종값]` | m/s² 단위의 가속도 (EKF 입력값) |

**단계별 계산:**
```
1단계: g 단위 변환
   -83 ÷ 16384 = -0.00506... g

2단계: m/s² 변환
   -0.00506 × 9.80665 = -0.0497 m/s²
```

---

#### ▶ ACCEL_Y 계산 분해

$$
a_y = \frac{200}{16384} \times 9.80665 \approx \mathbf{0.1197 \, m/s^2}
$$

**단계별 계산:**
```
1단계: g 단위 변환
   200 ÷ 16384 = 0.01221... g

2단계: m/s² 변환
   0.01221 × 9.80665 = 0.1197 m/s²
```

---

### 🧮 자이로 변환 공식 (상세)

$$
\omega_{(rad/s)} = \frac{\text{Raw Data}}{\text{Sensitivity}} \times \frac{\pi}{180}
$$

> **왜 π/180?** 삼각함수(sin, cos)는 라디안(radian) 단위를 사용하기 때문입니다.
> - 180° = π rad
> - 1° = π/180 rad ≈ 0.0174533

---

#### ▶ GYRO_Z 계산 분해

$$
\omega_z = \frac{750}{131} \times \frac{\pi}{180} \approx \mathbf{0.0999 \, rad/s}
$$

**각 요소의 의미:**

| 기호 | 값 | 설명 |
|------|-----|------|
| 750 | `[Raw Data]` | 센서 레지스터에서 읽어온 16비트 정수 원본 값 |
| 131 | `[Sensitivity]` | ±250°/s 모드에서 1°/s = 131 LSB |
| 5.725 | `[중간값]` | °/s 단위로 변환된 값 (초당 약 5.7도 회전) |
| π/180 | `[변환 상수]` | °→ rad 변환 (약 0.0174533) |
| **0.0999** | `[최종값]` | rad/s 단위의 각속도 (EKF 입력값) |

**단계별 계산:**
```
1단계: °/s 단위 변환
   750 ÷ 131 = 5.725... °/s

2단계: rad/s 변환
   5.725 × (π ÷ 180) = 5.725 × 0.0174533 = 0.0999 rad/s
```

---

### ✅ Step 2 결과: 입력 벡터 $u_k$

센서 Raw Data를 물리 단위로 변환한 결과입니다. 이것이 EKF의 **입력값(Input)**이 됩니다.

$$
u_k = \begin{bmatrix} a_x \\ a_y \\ \omega_z \end{bmatrix} = \begin{bmatrix} -0.0497 \, m/s^2 \\ 0.1197 \, m/s^2 \\ 0.0999 \, rad/s \end{bmatrix}
$$

---

## 4. Step 3: EKF 예측 단계 계산

### 🤔 왜 이 과정이 필요한가요?

센서값(가속도, 각속도)을 알았으니, 이제 **"시간이 지나면 위치와 속도가 어떻게 변할까?"**를 계산합니다.
이것이 칼만 필터의 **Prediction(예측) 단계**입니다.

### 📌 사용되는 물리 공식

고등학교 물리에서 배운 **등가속도 운동 공식**을 그대로 사용합니다:

| 물리량 | 공식 | 의미 |
|--------|------|------|
| 위치 | $p = p_0 + v \cdot \Delta t + \frac{1}{2} a \cdot \Delta t^2$ | 위치 = 이전위치 + 속도×시간 + ½×가속도×시간² |
| 속도 | $v = v_0 + a \cdot \Delta t$ | 속도 = 이전속도 + 가속도×시간 |
| 방향 | $\theta = \theta_0 + \omega \cdot \Delta t$ | 방향 = 이전방향 + 각속도×시간 |

---

### A. 초기 상태 정의

**이전 상태 벡터** $x_{k-1}$ (직전 시점에 계산되어 저장된 값):

$$
x_{k-1} = \begin{bmatrix} p_x \\ p_y \\ v_x \\ v_y \\ \theta \end{bmatrix} = \begin{bmatrix} 0 \\ 0 \\ 1.5 \\ 0.5 \\ 0 \end{bmatrix}
$$

| 상태 변수 | 값 | 의미 |
|-----------|-----|------|
| $p_x$ | 0 m | X축 위치 (시작점) |
| $p_y$ | 0 m | Y축 위치 (시작점) |
| $v_x$ | 1.5 m/s | X축 속도 (앞으로 걷는 중) |
| $v_y$ | 0.5 m/s | Y축 속도 (약간 옆으로) |
| $\theta$ | 0 rad | 바라보는 방향 (정면) |

**시간 간격 ($\Delta t$):** 0.01초 (100Hz 샘플링)

---

### B. 좌표계 회전 (Body Frame → Global Frame)

**❓ 이게 뭔가요?**

가속도 센서는 **센서 자체(Body)**를 기준으로 측정합니다. 하지만 우리는 **지도(Global)** 기준으로 위치를 계산해야 합니다.

예를 들어:
- 사용자가 **동쪽**을 보고 있을 때 "앞으로 가속" = 동쪽 가속
- 사용자가 **북쪽**을 보고 있을 때 "앞으로 가속" = 북쪽 가속

현재 방향($\theta$)에 따라 가속도를 회전시켜야 합니다.

**회전 변환 공식:**
$$
a_{global\_x} = a_x \cos\theta - a_y \sin\theta
$$
$$
a_{global\_y} = a_x \sin\theta + a_y \cos\theta
$$

**현재 예제에서:**

$\theta = 0$ 이므로, $\cos(0) = 1$, $\sin(0) = 0$

따라서 회전 없이 그대로:
- $a_{global\_x} = -0.0497 \times 1 - 0.1197 \times 0 = -0.0497 \, m/s^2$
- $a_{global\_y} = -0.0497 \times 0 + 0.1197 \times 1 = 0.1197 \, m/s^2$

---

### C. 상태 전이 계산 (State Transition)

#### ▶ 위치 예측

$$
p = p_0 + v \cdot \Delta t + \frac{1}{2} a \cdot \Delta t^2
$$

**X축 위치:**
```
p_x = 0 + (1.5 × 0.01) + (0.5 × -0.0497 × 0.01²)
    = 0 + 0.015 + (0.5 × -0.0497 × 0.0001)
    = 0 + 0.015 - 0.000002485
    ≈ 0.014997 m
```

**Y축 위치:**
```
p_y = 0 + (0.5 × 0.01) + (0.5 × 0.1197 × 0.01²)
    = 0 + 0.005 + (0.5 × 0.1197 × 0.0001)
    = 0 + 0.005 + 0.000005985
    ≈ 0.005006 m
```

---

#### ▶ 속도 예측

$$
v = v_0 + a \cdot \Delta t
$$

**X축 속도:**
```
v_x = 1.5 + (-0.0497 × 0.01)
    = 1.5 - 0.000497
    ≈ 1.4995 m/s
```

**Y축 속도:**
```
v_y = 0.5 + (0.1197 × 0.01)
    = 0.5 + 0.001197
    ≈ 0.5012 m/s
```

---

#### ▶ 방향 예측

$$
\theta = \theta_0 + \omega \cdot \Delta t
$$

```
θ = 0 + (0.0999 × 0.01)
  = 0 + 0.000999
  ≈ 0.0010 rad   (약 0.057°)
```

---

### ✅ Step 3 결과: 예측된 상태 벡터 $x_{k|k-1}$

$$
x_{k|k-1} = \begin{bmatrix} p_x \\ p_y \\ v_x \\ v_y \\ \theta \end{bmatrix} = \begin{bmatrix} 0.014997 \\ 0.005006 \\ 1.4995 \\ 0.5012 \\ 0.0010 \end{bmatrix}
$$

| 상태 변수 | 예측값 | 변화량 | 해석 |
|-----------|--------|--------|------|
| $p_x$ | 0.014997 m | +0.015 m | 0.01초 동안 약 1.5cm 전진 |
| $p_y$ | 0.005006 m | +0.005 m | 0.01초 동안 약 0.5cm 옆으로 이동 |
| $v_x$ | 1.4995 m/s | -0.0005 m/s | 미세하게 감속 |
| $v_y$ | 0.5012 m/s | +0.0012 m/s | 미세하게 측면 가속 |
| $\theta$ | 0.0010 rad | +0.001 rad | 약 0.06° 왼쪽으로 회전 |

---

## 5. 최종 결과 정리

### 📋 전체 데이터 흐름 요약

```
┌─────────────────────────────────────────────────────────────────────┐
│  입력: MPU-9250 Raw Data                                             │
│  ACCEL_X = -83, ACCEL_Y = 200, ACCEL_Z = 16500, GYRO_Z = 750        │
└─────────────────────────────────┬───────────────────────────────────┘
                                  │
                                  ▼
┌─────────────────────────────────────────────────────────────────────┐
│  Step 2: 물리 단위 변환                                              │
│  ax = -0.0497 m/s², ay = 0.1197 m/s², ωz = 0.0999 rad/s             │
└─────────────────────────────────┬───────────────────────────────────┘
                                  │
                                  ▼
┌─────────────────────────────────────────────────────────────────────┐
│  Step 3: EKF 예측 (dt = 0.01s)                                       │
│  위치: px=0.015m, py=0.005m                                          │
│  속도: vx=1.4995m/s, vy=0.5012m/s                                    │
│  방향: θ=0.001rad                                                    │
└─────────────────────────────────────────────────────────────────────┘
```

> **💡 중요 참고:**
> 이 계산은 칼만 필터의 **"Prediction(예측)"** 단계입니다. 
> 실제 시스템에서는 GPS 등 다른 센서 데이터가 들어오면 **"Correction(보정)"** 단계를 수행하여 예측값을 수정합니다.

---

## 6. 임베디드 최적화 팁

### ⚡ 성능 최적화: 상수 미리 계산하기

임베디드 시스템(MCU)에서는 **나눗셈과 실수 연산 비용이 큽니다.** 매번 계산하는 대신, 상수를 미리 계산해두세요.

```c
// ❌ 비효율적인 방법 (매번 나눗셈 + 곱셈)
float ax = (raw_accel_x / 16384.0f) * 9.80665f;
float omega = (raw_gyro_z / 131.0f) * (3.141592f / 180.0f);

// ✅ 효율적인 방법 (곱셈 한 번)
#define ACCEL_SCALE  (9.80665f / 16384.0f)      // ≈ 0.000598550
#define GYRO_SCALE   ((3.141592f / 180.0f) / 131.0f)  // ≈ 0.000133158

float ax = raw_accel_x * ACCEL_SCALE;
float omega = raw_gyro_z * GYRO_SCALE;
```

**효과:** CPU 사이클 절약, 실시간 성능 향상

---

## 📚 추가 참고 자료

- **MPU-9250 데이터시트**: Sensitivity Scale Factor 상세 정보
- **칼만 필터 이론**: 오차 공분산 행렬(P), 측정 보정(Update) 단계
- **좌표계 변환**: Euler Angle, Quaternion 표현 방식